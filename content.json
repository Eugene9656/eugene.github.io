{"meta":{"title":"Jeffのblog","subtitle":"热爱可抵岁月漫长","description":"个人开发博客，记录开发日常","author":"Jeff","url":"http://norhub.com.cn","root":"/"},"pages":[{"title":"","date":"2021-10-19T05:10:57.446Z","updated":"2021-04-30T02:53:19.000Z","comments":true,"path":"manifest.json","permalink":"http://norhub.com.cn/manifest.json","excerpt":"","text":"{\"name\":\"Rnazoroのblog\",\"short_name\":\"Rnazoro\",\"theme_color\":\"#49b1f5\",\"background_color\":\"#49b1f5\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"images/pwaicons/36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"images/pwaicons/512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"","date":"2021-10-19T05:10:37.186Z","updated":"2021-04-30T02:53:19.000Z","comments":true,"path":"404.html","permalink":"http://norhub.com.cn/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-10-19T05:10:57.446Z","updated":"2021-04-30T02:53:19.000Z","comments":true,"path":"about/index.html","permalink":"http://norhub.com.cn/about/index.html","excerpt":"","text":"这个人很懒，什么都没有留下"},{"title":"404 Not Found","date":"2021-10-19T05:10:57.446Z","updated":"2021-05-12T08:18:40.000Z","comments":true,"path":"404.html","permalink":"http://norhub.com.cn/404.html","excerpt":"","text":"{ % p center huge, 404 % } { % p center bold, 很抱歉，您访问的页面不存在 % } { % p center small, 可能是输入地址有误或该地址已被删除 % }"},{"title":"友链","date":"2021-10-19T05:10:57.446Z","updated":"2021-04-30T02:53:19.000Z","comments":true,"path":"friends/index.html","permalink":"http://norhub.com.cn/friends/index.html","excerpt":"","text":""},{"title":"相册","date":"2020-01-14T04:13:02.000Z","updated":"2021-04-30T02:53:19.000Z","comments":true,"path":"gallery/index.html","permalink":"http://norhub.com.cn/gallery/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-10-19T05:10:57.446Z","updated":"2021-04-30T02:53:19.000Z","comments":false,"path":"categories/index.html","permalink":"http://norhub.com.cn/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-10-19T05:10:57.446Z","updated":"2021-04-30T02:53:19.000Z","comments":true,"path":"tags/index.html","permalink":"http://norhub.com.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"普陀山Vlog","slug":"普陀山Vlog","date":"2021-07-20T05:25:43.000Z","updated":"2021-07-20T05:47:11.000Z","comments":true,"path":"2021/07/20/普陀山Vlog/","link":"","permalink":"http://norhub.com.cn/2021/07/20/%E6%99%AE%E9%99%80%E5%B1%B1Vlog/","excerpt":"","text":"your browser does not support the video tag","categories":[],"tags":[]},{"title":"正则表达式速查表","slug":"正则表达式速查表","date":"2021-07-12T08:19:14.000Z","updated":"2021-07-12T08:50:08.000Z","comments":true,"path":"2021/07/12/正则表达式速查表/","link":"","permalink":"http://norhub.com.cn/2021/07/12/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%9F%E6%9F%A5%E8%A1%A8/","excerpt":"","text":"表达式全集 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\”匹配“\\”而“(”则匹配“(”。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。*等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 &#123;n&#125; n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 &#123;n,&#125; n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 &#123;n,m&#125; m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 . 匹配除“\\n”之外的任何单个字符。要匹配包括“\\n”在内的任何字符，请使用像“(.|\\n)”的模式。 (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。 (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。 (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 (?&lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 (?&lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。 x\\|y 匹配x或y。例如，“z|food”能匹配“z”或“food”。“(z|f)ood”则匹配“zood”或“food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \\B 匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \\cx 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \\d 匹配一个数字字符。等价于[0-9]。 \\D 匹配一个非数字字符。等价于[^0-9]。 \\f 匹配一个换页符。等价于\\x0c和\\cL。 \\n 匹配一个换行符。等价于\\x0a和\\cJ。 \\r 匹配一个回车符。等价于\\x0d和\\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于\\x09和\\cI。 \\v 匹配一个垂直制表符。等价于\\x0b和\\cK。 \\w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 \\W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 \\xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\\x41”匹配“A”。“\\x041”则等价于“\\x04&amp;1”。正则表达式中可以使用ASCII编码。 \\num 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\\1”匹配两个连续的相同字符。 \\n 标识一个八进制转义值或一个向后引用。如果\\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 \\nm 标识一个八进制转义值或一个向后引用。如果\\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\\nm将匹配八进制转义值nm。 \\nml 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \\un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。 常用正则表达式 字符 描述 用户名 /^[a-z0-9_-]&#123;3,16&#125;$/ 密码 /^[a-z0-9_-]&#123;6,18&#125;$/ 十六进制值 /^#?([a-f0-9]&#123;6&#125;\\|[a-f0-9]&#123;3&#125;)$/ 电子邮箱 /^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)$//^[a-z\\d]+(\\.[a-z\\d]+)*@([\\da-z](-[\\da-z])?)+(\\.&#123;1,2&#125;[a-z]+)+$/ URL /^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)([\\/\\w \\.-]*)*\\/?$/ IP 地址 /((2[0-4]\\d\\|25[0-5]\\|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d\\|25[0-5]\\|[01]?\\d\\d?)//^(?:(?:25[0-5]\\|2[0-4][0-9]\\|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]\\|2[0-4][0-9]\\|[01]?[0-9][0-9]?)$/ HTML 标签 /^&lt;([a-z]+)([^&lt;]+)*(?:&gt;(.*)&lt;\\/\\1&gt;\\|\\s+\\/&gt;)$/ 删除代码\\注释 (?&lt;!http:\\|\\S)//.*$ Unicode编码中的汉字范围 /^[\\u2E80-\\u9FFF]+$/","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://norhub.com.cn/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"[转]用Python解数独","slug":"转-用Python解数独","date":"2021-06-01T15:15:47.000Z","updated":"2021-06-02T07:58:26.000Z","comments":true,"path":"2021/06/01/转-用Python解数独/","link":"","permalink":"http://norhub.com.cn/2021/06/01/%E8%BD%AC-%E7%94%A8Python%E8%A7%A3%E6%95%B0%E7%8B%AC/","excerpt":"","text":"芬兰数学家因卡拉花费3个月时间设计出的世界上迄今难度最大的数独。数独是 9 横 9 竖共有 81 个格子，同时又分为 9 个九宫格。规则很简单：每个空格填入 1~9 任意一个数字，需要保证每个横排和竖排以及九宫格内无相同数字。 解数独是一个可有可无的爱好，知道这个益智游戏，但是不很上心。但是前两天，由于自己的学生装了一个 ubuntu 18.04 的系统，上面有一些数独游戏，偶然间，让我看见了，为了更好的显摆自己的 Python 知识，决定用 Python 写一个程序，所以就有了下面的文字。 1、将待解的数独转换成 Python 矩阵 m = [ [6, 0, 0, 1, 0, 0, 7, 0, 8], [0, 0, 0, 8, 0, 0, 2, 0, 0], [2, 3, 8, 0, 5, 0, 1, 0, 0], [0, 0, 0, 0, 4, 0, 0, 9, 2], [0, 0, 4, 3, 0, 8, 6, 0, 0], [3, 7, 0, 0, 1, 0, 0, 0, 0], [0, 0, 3, 0, 7, 0, 5, 2, 6], [0, 0, 2, 0, 0, 4, 0, 0, 0], [9, 0, 7, 0, 0, 6, 0, 0, 4]] 就是这么简单，将待填写的空白格用 0 来代替。 2、寻找第一个空格位置 def start_pos(m:&quot;数独矩阵&quot;): &quot;&quot;&quot; 功能：返回第一个空白格的位置坐标&quot;&quot;&quot; for x in range(9): for y in range(9): if m[x][y] == 0: return x, y return False, False # 若数独已完成，则返回 False, False 找到 Python 矩阵中第一个是 0 的元素的位置坐标。 3、寻找下一个空格位置 def get_next(m:&quot;数独矩阵&quot;, x:&quot;空白格行数&quot;, y:&quot;空白格列数&quot;): &quot;&quot;&quot; 功能：获得下一个空白格在数独中的坐标。 &quot;&quot;&quot; for next_y in range(y+1, 9): # 下一个空白格和当前格在一行的情况 if m[x][next_y] == 0: return x, next_y for next_x in range(x+1, 9): # 下一个空白格和当前格不在一行的情况 for next_y in range(0, 9): if m[next_x][next_y] == 0: return next_x, next_y return -1, -1 # 若不存在下一个空白格，则返回 -1，-1 找到 Python 矩阵中下一个是 0 的元素的位置坐标。详细内容看注释。 4、寻找适合当前空格的数字的集合 def value(m:&quot;数独矩阵&quot;, x:&quot;空白格行数&quot;, y:&quot;空白格列数&quot;): &quot;&quot;&quot; 功能：返回符合&quot;每个横排和竖排以及 九宫格内无相同数字&quot;这个条件的有效值。 &quot;&quot;&quot; i, j = x//3, y//3 grid = [m[i*3+r][j*3+c] for r in range(3) for c in range(3)] v = set([x for x in range(1,10)]) - set(grid) - set(m[x]) - \\ set(list(zip(*m))[y]) return list(v) 每个空格可以填入 1~9 中的任意一个数字，但要符合规则：每个空格填入 1~9 任意一个数字，需要保证每个横排和竖排以及九宫格内无相同数字。下面的代码中的 grid 变量，保存的是当前位置所处的九宫格。v 变量是通过集合运算，将 1~9 这个数字集合中，与行的数字集合、列的数字集合以及九宫格的数字集合重叠的部分去除掉。剩余的部分就是符合条件的数字的集合。 5、使用递归尝试解数独（Sudoku） def try_sudoku(m:&quot;数独矩阵&quot;, x:&quot;空白格行数&quot;, y:&quot;空白格列数&quot;): &quot;&quot;&quot; 功能：试着填写数独 &quot;&quot;&quot; for v in value(m, x, y): m[x][y] = v next_x, next_y = get_next(m, x, y) if next_y == -1: # 如果无下一个空白格 return True else: end = try_sudoku(m, next_x, next_y) # 递归 if end: # 数独解完之后，此处的 end 会是 True return True m[x][y] = 0 # 在递归的过程中，如果数独没有解开， # 则回溯到上一个空白格 详细内容看注释。 6、代码展示 import random import sys sys.setrecursionlimit(100000) # 发现python默认的递归深度是很有限的 #（默认是1000），因此当递归深度超过999的 # 样子，就会引发这样的一个异常。def get_next(m:&quot;数独矩阵&quot;, x:&quot;空白格行数&quot;, y:&quot;空白格列数&quot;): &quot;&quot;&quot; 功能：获得下一个空白格在数独中的坐标。 &quot;&quot;&quot; for next_y in range(y+1, 9): # 下一个空白格和当前格在一行的情况 if m[x][next_y] == 0: return x, next_y for next_x in range(x+1, 9): # 下一个空白格和当前格不在一行的情况 for next_y in range(0, 9): if m[next_x][next_y] == 0: return next_x, next_y return -1, -1 # 若不存在下一个空白格，则返回 -1，-1 def value(m:&quot;数独矩阵&quot;, x:&quot;空白格行数&quot;, y:&quot;空白格列数&quot;): &quot;&quot;&quot; 功能：返回符合&quot;每个横排和竖排以及 九宫格内无相同数字&quot;这个条件的有效值。 &quot;&quot;&quot; i, j = x//3, y//3 grid = [m[i*3+r][j*3+c] for r in range(3) for c in range(3)] v = set([x for x in range(1,10)]) - set(grid) - set(m[x]) - \\ set(list(zip(*m))[y]) return list(v)def start_pos(m:&quot;数独矩阵&quot;): &quot;&quot;&quot; 功能：返回第一个空白格的位置坐标&quot;&quot;&quot; for x in range(9): for y in range(9): if m[x][y] == 0: return x, y return False, False # 若数独已完成，则返回 False, Falsedef try_sudoku(m:&quot;数独矩阵&quot;, x:&quot;空白格行数&quot;, y:&quot;空白格列数&quot;): &quot;&quot;&quot; 功能：试着填写数独 &quot;&quot;&quot; for v in value(m, x, y): m[x][y] = v next_x, next_y = get_next(m, x, y) if next_y == -1: # 如果无下一个空白格 return True else: end = try_sudoku(m, next_x, next_y) # 递归 if end: return True m[x][y] = 0 # 在递归的过程中，如果数独没有解开， # 则回溯到上一个空白格def sudoku(m): x, y = start_pos(m) try_sudoku(m, x, y) print(m) if __name__ == &quot;__main__&quot;: m = [ [6, 0, 0, 1, 0, 0, 7, 0, 8], [0, 0, 0, 8, 0, 0, 2, 0, 0], [2, 3, 8, 0, 5, 0, 1, 0, 0], [0, 0, 0, 0, 4, 0, 0, 9, 2], [0, 0, 4, 3, 0, 8, 6, 0, 0], [3, 7, 0, 0, 1, 0, 0, 0, 0], [0, 0, 3, 0, 7, 0, 5, 2, 6], [0, 0, 2, 0, 0, 4, 0, 0, 0], [9, 0, 7, 0, 0, 6, 0, 0, 4] ] sudoku(m) &quot;&quot;&quot; 数独结果如下：[ [6, 9, 5, 1, 2, 3, 7, 4, 8], [7, 4, 1, 8, 6, 9, 2, 5, 3], [2, 3, 8, 4, 5, 7, 1, 6, 9], [8, 1, 6, 7, 4, 5, 3, 9, 2], [5, 2, 4, 3, 9, 8, 6, 7, 1], [3, 7, 9, 6, 1, 2, 4, 8, 5], [4, 8, 3, 9, 7, 1, 5, 2, 6], [1, 6, 2, 5, 8, 4, 9, 3, 7], [9, 5, 7, 2, 3, 6, 8, 1, 4]]&quot;&quot;&quot; 原文地址 www.jianshu.com","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"程序开发/Python","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://norhub.com.cn/tags/python/"}]},{"title":"如何解决文件系统类型为RAW","slug":"如何解决文件系统类型为RAW","date":"2021-06-01T02:18:41.000Z","updated":"2021-06-03T03:28:10.000Z","comments":true,"path":"2021/06/01/如何解决文件系统类型为RAW/","link":"","permalink":"http://norhub.com.cn/2021/06/01/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B%E4%B8%BARAW/","excerpt":"","text":"如果您的计算机报告存储设备的文件系统类型是原始文件，那么您知道如何修复它吗？本文是关于在文件系统类型为原始文件时如何修复设备的信息。该解决方案适用于SD存储卡，USB闪存驱动器，外部硬盘驱动器，内部硬盘等。 文件系统的类型为Raw CHKDSK 当文件系统类型为原始文件时，您的设备将无法访问，并且无法被您的计算机系统识别。CHKDSK会告诉您“文件系统的类型为原始文件。CHKDSK不适用于原始驱动器。” 修复文件系统为原始文件 当您的设备转向原始驱动器时，它将变得不可访问，因此您需要将其转换为FAT32或NTFS。FAT 32和NTFS是Windows用户使用的普通文件系统。您可以将设备格式化为FAT 32或NTFS文件系统，以修复原始驱动器。 CMD命令行可以在您的系统上执行格式和转换，您可以按照说明修复原始文件系统错误。 注意：在此过程中，您需要非常小心，即使是很小的错误也会造成大问题，并使情况变得更糟，因此，当您使用CMD将文件系统转换为FAT32或NTFS时，请注意这一点。 步骤1：执行CMD。 步骤2：输入“ format F：/ fs：fat32”（F是RAW SD存储卡的驱动器号） 如果不起作用，请尝试以下步骤 这些步骤之后，您可以将设备文件系统转换为FAT32，但是此操作将格式化磁盘，这意味着您的数据将全部删除。 原始文件系统恢复而不会丢失数据 如果您的设备上有重要数据，则需要首先恢复数据，但是如何恢复呢？如果您没有在其他地方进行备份，则可以尝试使用数据恢复工具进行备份。 iCare Data Recovery Pro是有用的数据恢复程序，既安全又有效。它对我有很多帮助。它可以从多种设备中恢复数据，包括USB闪存驱动器，SD存储卡，外部硬盘驱动器，PC，智能手机。 如果您的计算机使用Windows系统，则无需担心系统兼容性问题，iCare Data Recovery支持所有Windows系统。当文件系统的类型为原始Windows 10/7/8 / vista时，您可以下载免费版本以修复错误。 免费下载iCare 原始文件系统数据恢复说明 步骤1：在计算机上安装程序。运行该程序，然后选择“深度扫描恢复”模式。 步骤2：选择要扫描的设备。 步骤3：预览找到的数据。 步骤4：选择所需的数据并保存到另一个位置。不要将数据保存到原始驱动器。 Windows无法完成格式化？ 有时，当您要格式化原始驱动器时，会遇到麻烦，无法完成格式化，Windows可能会报告“ Windows无法完成格式化”。正如我所讨论的如何将原始驱动器格式化为FAT32一样，您可以按照上面的说明进行尝试。您也可以尝试使用专业的格式工具来为您提供帮助。 您可以下载安全的格式化程序来完成格式化，这是一个很好的格式化程序：https : //www.icare-recovery.com/howto/free-usb-format-tool.html 提示 恢复数据并修复原始驱动器后，最好再购买一个新的USB闪存驱动器或硬盘驱动器，因为它可能再次损坏。 文件系统的类型在硬盘驱动器/外部驱动器上是原始的 如果您的计算机在将 U 盘、SD 存储卡、外置硬盘驱动器或其他外置驱动器插入计算机时报告需要格式化您的磁盘驱动器，则您的存储设备可能会出现原始文件系统错误。 当系统在 Windows 10/7 上说文件系统的类型为 Raw 时会发生什么 有很多原因会导致您的 U 盘/SD 存储卡/外置硬盘成为原始数据，如果您中断设备上的格式化，传输数据时弹出设备，感染病毒，在设备上运行不当操作，得到一个系统崩溃，或对设备做其他不好的事情，它可能会变得原始，有时，即使你什么也没做，你的设备也会以某种方式转向原始驱动器。","categories":[{"name":"其他","slug":"其他","permalink":"http://norhub.com.cn/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"cmd","slug":"cmd","permalink":"http://norhub.com.cn/tags/cmd/"}]},{"title":"VSCode有哪些常用的快捷键","slug":"VSCode有哪些常用的快捷键","date":"2021-05-24T10:31:26.000Z","updated":"2021-06-03T03:40:00.000Z","comments":true,"path":"2021/05/24/VSCode有哪些常用的快捷键/","link":"","permalink":"http://norhub.com.cn/2021/05/24/VSCode%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"CTRL+P 模式 直接输入文件名，快速打开文件 &gt; 可以回到主命令框 Ctrl+Shift+P 模式。 ? 列出当前可执行的动作 ! 显示 Errors 或 Warnings，也可以 Ctrl+Shift+M : 跳转到行数，也可以 Ctrl+G 直接进入 @ 跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入 @: 根据分类跳转 symbol，查找属性或函数，也可以 Ctrl+Shift+O 后输入: 进入 # 根据名字查找 symbol，也可以 Ctrl+T 编辑器与窗口管理 同时打开多个窗口（查看多个项目） 打开一个新窗口： Ctrl+Shift+N 关闭窗口： Ctrl+Shift+W 同时打开多个编辑器（查看多个文件） 新建文件 Ctrl+N 历史打开文件之间切换 Ctrl+Tab，Alt+Left，Alt+Right 切出一个新的编辑器（最多 3 个）Ctrl+\\，也可以按住 Ctrl 鼠标点击 Explorer 里的文件名 左中右 3 个编辑器的快捷键 Ctrl+1 Ctrl+2 Ctrl+3 3 个编辑器之间循环切换 Ctrl+`（不对） 编辑器换位置，Ctrl+k 然后按 Left 或 Right 代码编辑 格式调整 代码行缩进 Ctrl+[， Ctrl+] 折叠打开代码块 Ctrl+Shift+[， Ctrl+Shift+] Ctrl+C Ctrl+V 如果不选中，默认复制或剪切一整行 代码格式化：Shift+Alt+F，或 Ctrl+Shift+P 后输入 format code 上下移动一行： Alt+Up 或 Alt+Down 向上向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down 在当前行下边插入一行 Ctrl+Enter 在当前行上方插入一行 Ctrl+Shift+Enter 左侧边栏 打开资源 ctrl+shift+E 打开搜索 ctrl+shift+F 打开 git ctrl+shift+G 打开调试 ctrl+shift+D 打开扩展 ctrl+shift+X 光标相关 移动到行首：Home 移动到行尾：End 移动到文件结尾：Ctrl+End 移动到文件开头：Ctrl+Home 移动到后半个括号 Ctrl+Shift+] 选中当前行 Ctrl+i 选择从光标到行尾 Shift+End 选择从行首到光标处 Shift+Home 删除光标所在行 Ctrl+Delete Shrink/expand selection（光标所在单词，文档高亮显示相同的）： Shift+Alt+Left 和 Shift+Alt+Right Multi-Cursor：可以连续选择多处，然后一起修改，Alt+Click 添加 cursor 翻转 IDECtrl+Alt+Down 或 Ctrl+Alt+Up 同时选中所有匹配的 Ctrl+Shift+L Ctrl+D 下一个匹配的也被选中 (被我自定义成删除当前行了，见下边 Ctrl+Shift+K) 回退上一个光标操作 Ctrl+U 重构代码 跳转到定义处：F12 定义处缩略图：只看一眼而不跳转过去 Alt+F12 列出所有的引用：Shift+F12 同时修改本文件中所有匹配的：Ctrl+F12 重命名：比如要修改一个方法名，可以选中后按 F2，输入新的名字，回车，会发现所有的文件都修改过了。 跳转到下一个 Error 或 Warning：当有多个错误时可以按 F8 逐个跳转 查看 diff 在 explorer 里选择文件右键 Set file to compare，然后需要对比的文件上右键选择 Compare with 'file_name_you_chose'. 查找替换 查找 Ctrl+F 查找替换 Ctrl+H 整个文件夹中查找 Ctrl+Shift+F 匹配符： to match one or more characters in a path segment ? to match on one character in a path segment ** to match any number of path segments ,including none {} to group conditions (e.g. {/*.html,/*.txt} matches all html and txt files) [] to declare a range of characters to match (e.g., example.[0-9] to match on example.0,example.1, … 显示相关 全屏：F11 zoomIn/zoomOut：Ctrl + =/Ctrl + - 侧边栏显 / 隐：Ctrl+B 侧边栏 4 大功能显示： Show Explorer Ctrl+Shift+E Show SearchCtrl+Shift+F Show GitCtrl+Shift+G Show DebugCtrl+Shift+D 输出 Show OutputCtrl+Shift+U 预览 markdownCtrl+Shift+V 其他 自动保存：File -&gt; AutoSave ，或者 Ctrl+Shift+P，输入 auto ctrl k + ctrl s = 打开快捷键一览表。 在这里面、你可以查看、搜索、修改快捷键。 专门记述快捷键的官方文档： https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf VS Code 里面按下 F1、输入 shortcuts、回车，就会自动跳转到这个文档，这个方法可以查看这个文档的实时更新。","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"VSCode","slug":"程序开发/VSCode","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/VSCode/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://norhub.com.cn/tags/vscode/"}]},{"title":"科学上网一键搭建工具ProxySU","slug":"科学上网一键搭建工具ProxySU","date":"2021-05-19T14:08:45.000Z","updated":"2021-06-03T02:01:42.000Z","comments":true,"path":"2021/05/19/科学上网一键搭建工具ProxySU/","link":"","permalink":"http://norhub.com.cn/2021/05/19/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E4%B8%80%E9%94%AE%E6%90%AD%E5%BB%BA%E5%B7%A5%E5%85%B7ProxySU/","excerpt":"","text":"介绍 ProxySU是一款windows科学上网搭建软件，支持一键搭建V2ray，Trojan，NaiveProxy, Trojan-Go, ShadowsocksR(SSR),Shadowsocks-libev及相关插件一键安装工具。 准备 准备一台vps服务器，没有装过以上代理软件，如果已经安装过，最好将系统重装一下，会减少很多的麻烦。 准备好域名做dns解析 下载 Github地址：https://github.com/proxysu/windows/releases 目前最新版本是3.1.3,下载后双击ProxySU.exe打开 使用 打开后填入相应的选项，点击一键安装即可。 安装后会有弹出一个界面，上面有搭建好的代理配置参数，导入到相应的客户端即可使用。 安装后如需更换其他类型的代理，到系统工具里面点卸载代理，等待卸载完成后再选择其他代理进行安装。","categories":[{"name":"软件推荐","slug":"软件推荐","permalink":"http://norhub.com.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"name":"PC","slug":"软件推荐/PC","permalink":"http://norhub.com.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/PC/"}],"tags":[{"name":"代理","slug":"代理","permalink":"http://norhub.com.cn/tags/%E4%BB%A3%E7%90%86/"}]},{"title":"Git 命令速查表","slug":"GIT命令速查表","date":"2021-05-13T02:02:42.000Z","updated":"2021-10-19T02:55:35.653Z","comments":true,"path":"2021/05/13/GIT命令速查表/","link":"","permalink":"http://norhub.com.cn/2021/05/13/GIT%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/","excerpt":"","text":"Git 是一款流行的代码版本管理工具，本页提供了常用 Git 命令的速查功能，以及相关的术语参考，是程序开发人员必备的参考工具。 Git 常用命令 创建命令 Create Git 命令命令说明 git clone &lt;url&gt; 克隆远程仓库 git init 初始化本地 git 仓库（即创建新的本地仓库） 本地更改 Local Changes Git 命令命令说明 git status 查看当前分支状态 git diff 查看已跟踪文件的变更 git add &lt;file&gt; 将指定的文件添加到暂存区 git add . 将所有有变更的文件添加到暂存区 git commit -a 提交所有本地修改 git commit -m &quot;xxx&quot; 把已添加至暂存区的文件执行提交，并以 xxx 作为本次提交的描述 git commit --amend -m &quot;xxx&quot; 修改上一次提交（请勿用该命令修改已发布的提交） git commit -am &quot;xxx&quot; 该命令是 git add . 和 git commit -m &quot;xxx&quot; 的快捷方式 git commit -C HEAD -a -amend 增补提交（不会产生新的提交历史纪录） git pull 拉取代码及快速合并 git pull -r &lt;branch&gt; 拉取远程代码及快速合并 git push 提交到git服务器 git push origin branchName:branchName 推送本地的branchName(冒号前面的)分支到远程origin的branchName(冒号后面的)分支(没有会自动创建) git stash 暂存当前修改，将所有置为 HEAD 状态 git stash list 查看所有暂存列表 git stash push 把当前工作区的文件暂存到临时空间 git stash pop 把文件从临时空间中恢复到当前工作区 提交历史 Commit History Git 命令命令说明 git log 查看提交日志 git log -n 显示 n 行日志，n 为整数 git log --stat 查看本地提交日志 git show &lt;commit&gt; 查看提交日志及相关变动文件 git show HEAD 查看 HEAD 提交日志 git show HEAD^ 查看 HEAD 的上一个版本提交日志。另外，git show HEAD^^ 是查看上 2 个版本的提交日志；git show HEAD^5 是查看上 5 个版本的提交日志 git blame &lt;file&gt; 对于指定文件，逐行显示提交的哈希ID、提交者、提交日期以及修改的内容 git whatchanged 显示提交历史，以及每次提交变更的文件 gitk 查看当前分支历史纪录 gitk &lt;branch&gt; 查看某分支历史纪录 gitk --all 查看所有分支历史纪录 分支和标签 Branches &amp; Tags Git 命令命令说明 git branch 查看本地分支 git branch -r 查看远程分支 git branch -a 查看所有分支（本地和远程） git branch -v 每个分支最后的提交 git branch --merged 查看所有分支已合并到当前分支的分支 git branch --no-merged 查看所有分支未合并到当前分支的分支 git branch -m &lt;new-branch&gt; 把当前分支的名称改成 new-branch；如果 new-branch 已存在，将不会执行改名 git branch -M &lt;new-branch&gt; 强制把当前分支的名称改成 new-branch（即使 new-branch 已存在） git branch -m &lt;old-branch&gt; &lt;new-branch&gt; 把分支 old-branch 的名称改成 new-branch，如果 new-branch 已存在，将不会执行改名 git branch -M &lt;old-branch&gt; &lt;new-branch&gt; 强制把分支 old-branch 的名称改成 new-branch（即使 new-branch 已存在） git checkout &lt;branch-name&gt; 切换到 branch-name 分支 git checkout -b &lt;branch-name&gt; 于当前分支创建并切换到新分支 git branch &lt;new-branch&gt; 新建分支（也可以用 git checkout -b &lt;new-branch&gt;） git branch --track &lt;new&gt; &lt;remote&gt; 基于远程分支创建一个新分支，同 git checkout --track &lt;remote/branch&gt; git branch -d &lt;branch-name&gt; 删除本地分支 git push origin --delete &lt;branch-name&gt; 删除远程分支 git tag 列出所有本地标签 git tag &lt;tag-name&gt; 基于最新的提交创建标签 git tag -d &lt;tag-name&gt; 删除标签 删除命令 Remove Git 命令命令说明 git rm &lt;file&gt; 删除文件（将从磁盘中删除文件） git rm -r &lt;directory&gt; 递归删除指定目录下的文件 git rm --cached &lt;file&gt; 停止跟踪文件，不会从磁盘中删除 git mv &lt;old&gt; &lt;new&gt; 文件重命名 合并和衍合 Merge &amp; Rebase Git 命令命令说明 git merge &lt;branch&gt; 合并指定分支到当前分支，保留两个 git rebase &lt;branch&gt; 合并指定分支到当前分支，只保留一个 git rebase --abort 终止 rebase 操作，即回到执行 rebase 之前的状态 git rebase --continue 解决冲突后继续执行 rebase git mergetool 使用配置文件指定的 mergetool 解决冲突 git add &lt;resolved-file&gt;git rm &lt;resolved-file&gt; 使用编辑器手动解决文件冲突，并在冲突解决后，把文件标记为 resolved 撤销命令 Undo Git 命令命令说明 git reset --hard HEAD 将当前版本重置为 HEAD（用于 merge 失败的时候） git reflog 查看命令历史，历史中记录了回退前的commit id git reset &lt;commit&gt; 将当前版本重置为某一个提交状态，代码不变 git reset --hard &lt;commit&gt; 强制将当前版本重置为某一个提交状态，并丢弃那个状态之后的所有修改（请谨慎使用该命令） git reset --merge &lt;commit&gt; 将当前版本重置为某一个提交状态，并保留版本库中不同的文件 git reset --keep &lt;commit&gt; 将当前版本重置为某一个提交状态，并保留未提交的本地修改 git revert &lt;commit&gt; 撤销提交 git restore &lt;file&gt; 丢弃指定文件的修改信息，即恢复到文件修改前的状态 git checkout -- &lt;file&gt; 同 git restore &lt;file&gt; 命令 git checkout HEAD &lt;file&gt; 对于指定文件，丢弃该文件的本地修改信息 git clean 清除工作目录中未跟踪的文件 git clean -n 列出哪些文件将从工作目录中删除 git clean -df 回退所有未被跟踪的文件 跟踪文件 Git 命令命令说明 git update-index --no-assume-unchanged &lt;file&gt; 强制跟踪指定文件 git update-index --assume-unchanged &lt;file&gt; 强制不跟踪指定文件 远程命令 Remote Git 命令命令说明 git remote -v 查看远程版本库信息 git remote show &lt;remote&gt; 查看指定远程版本库信息 git remote add &lt;remote&gt; &lt;url&gt; 添加远程版本库 git fetch &lt;remote&gt; 从远程库获取代码 配置命令 Git Configuration Git 命令命令说明 git config --list 列出当前 Git 配置 git config --global user.name &lt;name&gt; 把参数 name 设置为当前用户使用的提交者的姓名；如果未指定 name 参数，则显示当前用户使用的提交者姓名 git config --global user.email &lt;email&gt; 把参数 email 设置为当前用户使用的提交者的邮箱；如果未指定 email 参数，则显示当前用户使用的提交者邮箱 git config --global alias.&lt;alias&gt; &lt;command&gt; 为 Git 命令创建全局的别名。比如，执行 alias.glog log --graph --oneline --decorate 命令后，git glog 就相当于 git log --graph --oneline --decorate。 git config --system core.editor &lt;editor&gt; 对于本机的所有用户，设置命令使用的编辑器（比如 vim） git config --global --edit 在编辑器中打开全局配置文件（用于手动修改） git config --global color.ui auto 使用不同的颜色渲染 Git 命令的输出结果 其他命令 Other Git 命令命令说明 git var -l 列出 Git 环境变量 git help &lt;command&gt; 显示指定命令的帮助（将呼出该命令的 man 文件） 相关术语 下面列出了 Git 常见的术语，通过这些术语，可以更好地了解 Git 版本控制系统。 git：一个开源的、分布式的版本控制系统 commit：提交，指一个 Git 对象，该对象是整个仓库以 SHA 表示的快照 branch：分支，一个轻量的、可移动的指向一个 commit 的指针 clone：克隆，指在本地创建一份远程仓库的副本 remote：远程仓库，是指托管在 GitHub、GitLab 等地方的公共（或私有）仓库，团队所有成员均可向该仓库提交修改 fork：创建一个其他用户的仓库的副本 pull request：简称 PR，指针对某个仓库，请求别人拉取并合并你的修改。通常，发起 pull request 的人都是从被请求人那里 clone 代码 HEAD：表示当前工作区，使用 git checkout命令，可以把 HEAD 指针切换到不同的分支、标签和 commit 上 常见问题 Failed to connect to github.com port 443: Operation timed out 如果您使用代理进行网络连接，则必须将代理添加到git config文件中。 您需要通过在终端或命令行中运行此命令来配置Git以使用代理设置。 git config --global http.proxy http://proxyuser:proxypwd@proxy.server.com:8080 其中proxyuser和proxypwd是您的凭据，proxy.server.com:8080是您连接到的服务器名称和端口。 Unsupported proxy syntax in '127.0.0.1:8118' 首先查看git的配置列表 git config --list 可以看到有两个代理配置，http.proxy和https.proxy，就是这两个配置的原因 删除这两项 git config --global --unset http.proxygit config --global --unset https.prox 从单个文件历史记录中搜索 git rev-list --all build_scripts/campaign/client/Security/TGL/security_L2.xml | ( while read revision; do git grep -F &#x27;CSS-IVE-122226&#x27; $revision build_scripts/campaign/client/Security/TGL/security_L2.xml done)","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"GIT","slug":"程序开发/GIT","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/GIT/"}],"tags":[{"name":"git","slug":"git","permalink":"http://norhub.com.cn/tags/git/"}]},{"title":"你应该知道的Python3各个版本的新特性","slug":"你应该知道的Python3各个版本的新特性","date":"2020-11-27T06:12:26.000Z","updated":"2021-05-21T04:01:22.000Z","comments":true,"path":"2020/11/27/你应该知道的Python3各个版本的新特性/","link":"","permalink":"http://norhub.com.cn/2020/11/27/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84Python3%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"最近在使用python过程中，看到了一段提示文本。发现python3.5的使用寿命已于2020年9月13日结束，pip 21.0也将于2021年1月删除对Python 3.5的支持。导致很多第三方模块要求python的最低标准是python3.6。 现在是时候升级你的python了，学习新版本python特性有助于提高对python的了解。","text":"最近在使用python过程中，看到了一段提示文本。发现python3.5的使用寿命已于2020年9月13日结束，pip 21.0也将于2021年1月删除对Python 3.5的支持。导致很多第三方模块要求python的最低标准是python3.6。 现在是时候升级你的python了，学习新版本python特性有助于提高对python的了解。 一、Python3.6新的语法特性 1、格式化字符串（Formatted string literals） 即在普通字符串前添加 f 或 F 前缀，其效果类似于str.format()。比如 name = &quot;Fred&quot;print(f&quot;He said his name is &#123;name&#125;.&quot;) # &#x27;He said his name is Fred.&#x27; 其效果相当于： print(&quot;He said his name is &#123;name&#125;.&quot;.format(**locals())) 此外，此特性还支持嵌套字段，比如： width = 10precision = 4value = decimal.Decimal(&quot;12.34567&quot;)print(f&quot;result: &#123;value:&#123;width&#125;.&#123;precision&#125;&#125;&quot;) #&#x27;result: 12.35&#x27; 2、变量声明语法（variable annotations） 即从Python3.5开始就有的Typehints。在Python3.5中，是这么使用的： from typing import List def test(a: List[int], b: int) -&gt; int: return a[0] + b print(test([3, 1], 2)) 这里的语法检查只在编辑器（比如Pycharm）中产生，在实际的使用中，并不进行严格检查。 在Python3.6中，引入了新的语法： from typing import List, Dict primes: List[int] = []captain: str # 此时没有初始值 class Starship: stats: Dict[str, int] = &#123;&#125; 3、数字的下划线写法（Underscores in Numeric Literals） 即允许在数字中使用下划线，以提高多位数字的可读性。 a = 1_000_000_000_000_000 # 1000000000000000b = 0x_FF_FF_FF_FF # 4294967295 除此之外，“字符串格式化”也支持“_”选项，以打印出更易读的数字字符串： &#x27;&#123;:_&#125;&#x27;.format(1000000) # &#x27;1_000_000&#x27;&#x27;&#123;:_x&#125;&#x27;.format(0xFFFFFFFF) # &#x27;ffff_ffff&#x27; 4、异步生成器（Asynchronous Generators） 在Python3.5中，引入了新的语法 async 和 await 来实现协同程序。但是有个限制，不能在同一个函数体内同时使用 yield 和 await，在Python3.6中，这个限制被放开了，Python3.6中允许定义异步生成器： async def ticker(delay, to):&quot;&quot;&quot;Yield numbers from 0 to *to* every *delay* seconds.&quot;&quot;&quot; for i in range(to): yield i await asyncio.sleep(delay) 5、异步解析器（Asynchronous Comprehensions） 即允许在列表list、集合set 和字典dict 解析器中使用 async for 或 await 语法。 result = [i async for i in aiter() if i % 2]result = [await fun() for fun in funcs if await condition()] 6、新增标准模块 Python标准库（The Standard Library）中增加了一个新的模块：secrets。该模块用来生成一些安全性更高的随机数，以用来管理数据，比如passwords, account authentication, security tokens, 以及related secrets等。具体用法可参考官方文档：secrets 7、其他新特性 新的 PYTHONMALLOC 环境变量允许开发者设置内存分配器，以及注册debug钩子等。 asyncio模块更加稳定、高效，并且不再是临时模块，其中的API也都是稳定版的了。 typing模块也有了一定改进，并且不再是临时模块。 datetime.strftime 和 date.strftime 开始支持ISO 8601的时间标识符%G, %u, %V。 hashlib 和 ssl 模块开始支持OpenSSL1.1.0。 hashlib模块开始支持新的hash算法，比如BLAKE2, SHA-3 和 SHAKE。 Windows上的 filesystem 和 console 默认编码改为UTF-8。 json模块中的 json.load() 和 json.loads() 函数开始支持 binary 类型输入。 ....... 更多新功能，参考官方文档：https://docs.python.org/3/whatsnew/3.6.html 二、Python3.7 新特性 Python 3.7 于 2018 年 6 月 27 日发布， 包含许多新特性和优化，增添了众多新的类，可用于数据处理、针对脚本编译和垃圾收集的优化以及更快的异步 I/O，主要如下： 用类处理数据时减少样板代码的数据类。 一处可能无法向后兼容的变更涉及处理生成器中的异常。 面向解释器的 “开发模式”。 具有纳秒分辨率的时间对象。 环境中默认使用 UTF-8 编码的 UTF-8 模式。 触发调试器的一个新的内置函数。 1、新增内置函数 breakpoint() 使用该内置函数，相当于通过代码的方式设置了断点，会自动进入 Pbd 调试模式。 如果在环境变量中设置 PYTHONBREAKPOINT=0 会忽略此函数。并且，pdb 只是众多可用调试器之一，你可以通过设置新的 PYTHONBREAKPOINT 环境变量来配置想要使用的调试器。 下面有一个简单例子，用户需要输入一个数字，判断它是否和目标数字一样： def guess(target): user_guess = input(&quot;请输入你猜的数 &gt;&gt;&gt; &quot;) if user_guess == target: return &quot;你猜对了!&quot; else: return &quot;猜错了&quot;if __name__ == &#x27;__main__&#x27;: a = 100 print(guess(a)) 不幸的是，即使猜的数和目标数一样，打印的结果也是‘猜错了'，并且没有任何异常或错误信息。 为了弄清楚发生了什么，我们可以插入一个断点，来调试一下。以往一般通过 print 大法或者 IDE 的调试工具，但现在我们可以使用 breakpoint()。 def guess(target): user_guess = input(&quot;请输入你猜的数 &gt;&gt;&gt; &quot;) breakpoint() //加入这一行 if user_guess == target: return &quot;你猜对了!&quot; else: return &quot;猜错了&quot;if __name__ == &#x27;__main__&#x27;: a = 100 print(guess(a)) 在 pdb 提示符下，我们可以调用 locals() 来查看当前的本地作用域的所有变量。（pdb 有大量的命令，你也可以在其中运行正常的 Python 语句） 请输入你猜的数 &gt;&gt;&gt; 100&gt; d:\\work\\for_test\\py3_test\\test.py(7)guess()-&gt; if user_guess == target:(Pdb) locals()&#123;&#x27;target&#x27;: 100, &#x27;user_guess&#x27;: &#x27;100&#x27;&#125;(Pdb) type(user_guess) 搞明白了，target 是一个整数，而 user_guess 是一个字符串，这里发生了类型对比错误。 2、类型和注解 从 Python 3.5 开始，类型注解就越来越受欢迎。对于那些不熟悉类型提示的人来说，这是一种完全可选的注释代码的方式，以指定变量的类型。 什么是注解？它们是关联元数据与变量的语法支持，可以是任意表达式，在运行时被 Python 计算但被忽略。注解可以是任何有效的 Python 表达式。 下面是个对比的例子： def foo(bar, baz):def foo(bar: &#x27;Describe the bar&#x27;, baz: print(&#x27;random&#x27;)) -&gt; &#x27;return thingy&#x27;: 上面的做法，其实是 Python 对自身弱类型语言的强化，希望获得一定的类型可靠和健壮度，向 Java 等语言靠拢。 在 Python 3.5 中，注解的语法获得标准化，此后，Python 社区广泛使用了注解类型提示。 但是，注解仅仅是一种开发工具，可以使用 PyCharm 等 IDE 或 Mypy 等第三方工具进行检查，并不是语法层面的限制。 我们前面的猜数程序如果添加类型注解，它应该是这样的： def guess(target:str): user_guess:str = input(&quot;请输入你猜的数 &gt;&gt;&gt; &quot;) breakpoint() if user_guess == target: return &quot;你猜对了!&quot; else: return &quot;猜错了&quot;if __name__ == &#x27;__main__&#x27;: a:int = 100 print(guess(a)) PyCharm 会给我们灰色的规范错误提醒，但不会给红色的语法错误提示。 用注解作为类型提示时，有两个主要问题：启动性能和前向引用。 在定义时计算大量任意表达式相当影响启动性能，而且 typing 模块非常慢 你不能用尚未声明的类型来注解 typing 模块如此缓慢的部分原因是，最初的设计目标是在不修改核心 CPython 解释器的情况下实现 typing 模块。随着类型提示变得越来越流行，这一限制已经被移除，这意味着现在有了对 typing 的核心支持。 而对于向前引用，看下面的例子： class User: def __init__(self, name: str, prev_user: User) -&gt; None: pass 错误在于 User 类型还没有被声明，此时的 prev_user 不能定义为 User 类型。 为了解决这个问题，Python3.7 将注解的评估进行了推迟。并且，这项改动向后不兼容，需要先导入 annotations，只有到 Python 4.0 后才会成为默认行为。 from __future__ import annotationsclass User: def __init__(self, name: str, prev_user: User) -&gt; None: pass 或者如下面的例子： class C: def validate_b(self, obj: B) -&gt; bool: ...class B: ... 3、新增 dataclasses 模块 这个特性可能是 Python3.7 以后比较常用的，它有什么作用呢？ 假如我们需要编写一个下面的类： from datetime import datetimeimport dateutilclass Article(object): def __init__(self, _id, author_id, title, text, tags=None, created=datetime.now(), edited=datetime.now()): self._id = _id self.author_id = author_id self.title = title self.text = text self.tags = list() if tags is None else tags self.created = created self.edited = edited if type(self.created) is str: self.created = dateutil.parser.parse(self.created) if type(self.edited) is str: self.edited = dateutil.parser.parse(self.edited) def __eq__(self, other): if not isinstance(other, self.__class__): return NotImplemented return (self._id, self.author_id) == (other._id, other.author_id) def __lt__(self, other): if not isinstance(other, self.__class__): return NotImplemented return (self._id, self.author_id) &lt; (other._id, other.author_id) def __repr__(self): return &#x27;&#123;&#125;(id=&#123;&#125;, author_id=&#123;&#125;, title=&#123;&#125;)&#x27;.format( self.__class__.__name__, self._id, self.author_id, self.title) 大量的初始化属性要定义默认值，可能还需要重写一堆魔法方法，来实现类实例的打印、比较、排序和去重等功能。 如果使用 dataclasses 进行改造，可以写成这个样子： from dataclasses import dataclass, fieldfrom typing import Listfrom datetime import datetimeimport dateutil@dataclass(order=True) #注意这里class Article(object): _id: int author_id: int title: str = field(compare=False) text: str = field(repr=False, compare=False) tags: List[str] = field(default=list(), repr=False, compare=False) created: datetime = field(default=datetime.now(), repr=False, compare=False) edited: datetime = field(default=datetime.now(), repr=False, compare=False) def __post_init__(self): if type(self.created) is str: self.created = dateutil.parser.parse(self.created) if type(self.edited) is str: self.edited = dateutil.parser.parse(self.edited) 这使得类不仅容易设置，而且当我们创建一个实例并打印出来时，它还可以自动生成优美的字符串。在与其他类实例进行比较时，它也会有适当的行为。这是因为 dataclasses 除了帮我们自动生成 init 方法外，还生成了一些其他特殊方法，如 repr、eq 和 hash 等。 Dataclasses 使用字段 field 来完提供默认值，手动构造一个 field() 函数能够访问其他选项，从而更改默认值。例如，这里将 field 中的 default_factory 设置为一个 lambda 函数，该函数提示用户输入其名称。 from dataclasses import dataclass, fieldclass User: name: str = field(default_factory=lambda: input(&quot;enter name&quot;)) 4、生成器异常处理 在 Python 3.7 中，生成器引发 StopIteration 异常后，StopIteration 异常将被转换成 RuntimeError 异常，那样它不会悄悄一路影响应用程序的堆栈框架。这意味着如何处理生成器的行为方面不太敏锐的一些程序会在 Python 3.7 中抛出 RuntimeError。在 Python 3.6 中，这种行为生成一个弃用警告；在 Python 3.7 中，它将生成一个完整的错误。 一个简易的方法是使用 try/except 代码段，在 StopIteration 传播到生成器的外面捕获它。更好的解决方案是重新考虑如何构建生成器――比如说，使用 return 语句来终止生成器，而不是手动引发 StopIteration。 5、开发模式 Python 解释器添加了一个新的命令行开关：-X，让开发人员可以为解释器设置许多低级选项。 这种运行时的检查机制通常对性能有重大影响，但在调试过程中对开发人员很有用。 -X 激活的选项包括： asyncio 模块的调试模式。这为异步操作提供了更详细的日志记录和异常处理，而异常操作可能很难调试或推理。 面向内存分配器的调试钩子。这对于编写 CPython 扩展件的那些人很有用。它能够实现更明确的运行时检查，了解 CPython 如何在内部分配内存和释放内存。 启用 faulthandler 模块，那样发生崩溃后，traceback 始终转储出去。 6、 高精度时间函数 Python 3.7 中一类新的时间函数返回纳秒精度的时间值。尽管 Python 是一种解释型语言，但是 Python 的核心开发人员维克多 • 斯廷纳（Victor Stinner）主张报告纳秒精度的时间。最主要的原因是，在处理转换其他程序（比如数据库）记录的时间值时，可以避免丢失精度。 新的时间函数使用后缀_ns。比如说，time.process_time() 的纳秒版本是 time.process_time_ns()。请注意，并非所有的时间函数都有对应的纳秒版本。 7、其他新特性 字典现在保持插入顺序。这在 3.6 中是非正式的，但现在成为了官方语言规范。在大多数情况下，普通的 dict 能够替换 collections.OrderedDict。 .pyc 文件具有确定性，支持可重复构建 —— 也就是说，总是为相同的输入文件生成相同的 byte-for-byte 输出。 新增 contextvars 模块，针对异步任务提供上下文变量。 __main__中的代码会显示弃用警告（DeprecationWarning）。 新增 UTF-8 模式。在 Linux/Unix 系统，将忽略系统的 locale，使用 UTF-8 作为默认编码。在非 Linux/Unix 系统，需要使用 - X utf8 选项启用 UTF-8 模式。 允许模块定义__getattr__、__dir__函数，为弃用警告、延迟 import 子模块等提供便利。 新的线程本地存储 C 语言 API。 更新 Unicode 数据到 11.0。 三、Python3.8 新特性 Python3.8 版本于 2019 年 10 月 14 日发布，以下是 Python 3.8 相比 3.7 的新增特性。 1、海象赋值表达式 新的语法 :=，将值赋给一个更大的表达式中的变量。它被亲切地称为 “海象运算符”(walrus operator)，因为它长得像海象的眼睛和象牙。 “海象运算符” 在某些时候可以让你的代码更整洁，比如： 在下面的示例中，赋值表达式可以避免调用 len () 两次: if (n := len(a)) &gt; 10: print(f&quot;List is too long (&#123;n&#125; elements, expected &lt;= 10)&quot;) 类似的好处还可体现在正则表达式匹配中需要使用两次匹配对象的情况中，一次检测用于匹配是否发生，另一次用于提取子分组: discount = 0.0 if (mo := re.search(r&#x27;(\\d+)% discount&#x27;, advertisement)): discount = float(mo.group(1)) / 100.0 此运算符也可用于配合 while 循环计算一个值，来检测循环是否终止，而同一个值又在循环体中再次被使用的情况: while (block := f.read(256)) != &#x27;&#x27;: process(block) 或者出现于列表推导式中，在筛选条件中计算一个值，而同一个值又在表达式中需要被使用: [clean_name.title() for name in names if (clean_name := normalize(&#x27;NFC&#x27;, name)) in allowed_names] 请尽量将海象运算符的使用限制在清晰的场合中，以降低复杂性并提升可读性。 2、仅限位置形参 新增一个函数形参语法 / 用来指明某些函数形参必须使用仅限位置而非关键字参数的形式。 这种标记语法与通过 help () 所显示的使用 Larry Hastings 的 Argument Clinic 工具标记的 C 函数相同。 在下面的例子中，形参 a 和 b 为仅限位置形参，c 或 d 可以是位置形参或关键字形参，而 e 或 f 要求为关键字形参: def f(a, b, /, c, d, *, e, f): print(a, b, c, d, e, f) 以下是合法的调用: f(10, 20, 30, d=40, e=50, f=60) 但是，以下均为不合法的调用: f(10, b=20, c=30, d=40, e=50, f=60) f(10, 20, 30, 40, 50, f=60) 这种标记形式的一个用例是它允许纯 Python 函数完整模拟现有的用 C 代码编写的函数的行为。例如，内置的 pow () 函数不接受关键字参数: def pow(x, y, z=None, /): &quot;Emulate the built in pow() function&quot; r = x ** y return r if z is None else r%z 另一个用例是在不需要形参名称时排除关键字参数。例如，内置的 len () 函数的签名为 len (obj, /)。这可以排除如下这种笨拙的调用形式: 另一个益处是将形参标记为仅限位置形参将允许在未来修改形参名而不会破坏客户的代码。例如，在 statistics 模块中，形参名 dist 在未来可能被修改。这使得以下函数描述成为可能: def quantiles(dist, /, *, n=4, method=&#x27;exclusive&#x27;) ... 由于在 / 左侧的形参不会被公开为可用关键字，其他形参名仍可在 **kwargs 中使用: &gt;&gt;&gt; def f(a, b, /, **kwargs): ... print(a, b, kwargs) ... &gt;&gt;&gt; f(10, 20, a=1, b=2, c=3) 10 20 &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125; 这极大地简化了需要接受任意关键字参数的函数和方法的实现。例如，下面是 collections 模块中的代码摘录： class Counter(dict): def __init__(self, iterable=None, /, **kwds): 3、f 字符串支持 增加 = 说明符用于 f-string。形式为 f'{expr=}' 的 f 字符串将扩展表示为表达式文本，加一个等于号，再加表达式的求值结果。例如： &gt;&gt;&gt; user = &#x27;eric_idle&#x27; &gt;&gt;&gt; member_since = date(1975, 7, 31) &gt;&gt;&gt; f&#x27;&#123;user=&#125; &#123;member_since=&#125;&#x27; &quot;user=&#x27;eric_idle&#x27; member_since=datetime.date(1975, 7, 31)&quot;f 字符串格式说明符允许更细致地控制所要显示的表达式结果:&gt;&gt;&gt; delta = date.today() - member_since &gt;&gt;&gt; f&#x27;&#123;user=!s&#125; &#123;delta.days=:,d&#125;&#x27; &#x27;user=eric_idle delta.days=16,075&#x27;= 说明符将输出整个表达式，以便详细演示计算过程:&gt;&gt;&gt; print(f&#x27;&#123;theta=&#125; &#123;cos(radians(theta))=:.3f&#125;&#x27;) theta=30 cos(radians(theta))=0.866 4、typing 模块的改进 Python 是动态类型语言，但可以通过 typing 模块添加类型提示，以便第三方工具验证 Python 代码。Python 3.8 给 typing 添加了一些新元素，因此它能够支持更健壮的检查： final 修饰器和 Final 类型标注表明，被修饰或被标注的对象在任何时候都不应该被重写、继承，也不能被重新赋值。 Literal 类型将表达式限定为特定的值或值的列表（不一定是同一个类型的值）。 TypedDict 可以用来创建字典，其特定键的值被限制在一个或多个类型上。注意这些限制仅用于编译时确定值的合法性，而不能在运行时进行限制。 5、多进程共享内存 multiprocessing 模块新增 SharedMemory 类，可以在不同的 Python 进城之间创建共享的内存区域。 在旧版本的 Python 中，进程间共享数据只能通过写入文件、通过网络套接字发送，或采用 Python 的 pickle 模块进行序列化等方式。共享内存提供了进程间传递数据的更快的方式，从而使得 Python 的多处理器和多内核编程更有效率。 共享内存片段可以作为单纯的字节区域来分配，也可以作为不可修改的类似于列表的对象来分配，其中能保存数字类型、字符串、字节对象、None 对象等一小部分 Python 对象。 6、新版本的 pickle 协议 Python 的 pickle 模块提供了一种序列化和反序列化 Python 数据结构或实例的方法，可以将字典原样保存下来供以后读取。不同版本的 Python 支持的 pickle 协议不同，而 3.8 版本的支持范围更广、更强大、更有效的序列化。 Python 3.8 引入的第 5 版 pickle 协议可以用一种新方法 pickle 对象，它能支持 Python 的缓冲区协议，如 bytes、memoryviews 或 Numpy array 等。新的 pickle 避免了许多在 pickle 这些对象时的内存复制操作。 NumPy、Apache Arrow 等外部库在各自的 Python 绑定中支持新的 pickle 协议。新的 pickle 也可以作为 Python 3.6 和 3.7 的插件使用，可以从 PyPI 上安装。 7、性能改进 许多内置方法和函数的速度都提高了 20%~50%，因为之前许多函数都需要进行不必要的参数转换。 一个新的 opcode 缓存可以提高解释器中特定指令的速度。但是，目前实现了速度改进的只有 LOAD_GLOBAL opcode，其速度提高了 40%。以后的版本中也会进行类似的优化。 文件复制操作如 shutil.copyfile() 和 shutil.copytree() 现在使用平台特定的调用和其他优化措施，来提高操作速度。 新创建的列表现在平均比以前小了 12%，这要归功于列表构造函数如果能提前知道列表长度的情况下，可以进行优化。 Python 3.8 中向新型类（如 class A(object)）的类变量中的写入操作变得更快。operator.itemgetter() 和 collections.namedtuple() 也得到了速度优化。 更多详细特性，请查阅 Python 3.8.0 文档：https://docs.python.org/zh-cn/3.8/whatsnew/3.8.html 四、Python3.9新特性 Python3.9 的一些新特性，如：更快速的进程释放，性能的提升，简便的新字符串函数，字典并集运算符以及更兼容稳定的内部 API，详细如下： 字典并集和可迭代更新 字符串方法 类型提示 新的数学函数 新的解析器 IPv6 范围内的地址 新模块：区域信息 其他语言更改 1、字典并集和可迭代更新 Python 3.9 dict 类。如果有两个字典 a 和 b，则现在可以使用这些运算符进行合并和更新。 我们有合并运算符 |： 使用 Iterables 进行字典更新 | = 运算符的另一个很棒的性能是能够使用可迭代对象（如列表或生成器）用新的键值对来更新字典： a = &#123;&#x27;a&#x27;: &#x27;one&#x27;, &#x27;b&#x27;: &#x27;two&#x27;&#125;b = ((i, i**2) for i in range(3))a |= bprint(a)&#123;&#x27;a&#x27;: &#x27;one&#x27;, &#x27;b&#x27;: &#x27;two&#x27;, 0: 0, 1: 1, 2: 4&#125; 2、字符串方法 removeprefix（）和 removesuffix（） str.removeprefix（substring：string）字符串方法：如果 str 以它开头的话，将会返回一个修改过前缀的新字符串，否则它将返回原始字符串。 str.removesuffix（substring：string）字符串方法：如果 str 以其结尾，则返回带有修改过后缀的新字符串，否则它将返回原始字符串。 这两个函数执行的操作将使用 string [len（prefix）：] 作为前缀，string [：-len（suffix）] 作为后缀。 这些是非常简单的操作，因此实现的也是非常简单的功能，但是考虑到可能会经常执行这些操作，最好有一个内置的函数可以完成此操作。 3、类型提示 Python 是动态类型的，动态地为变量指定数据类型，意味着我们无需在代码中指定数据类型。 但有时可能会造成混淆！ 对于数据类型的静态分配，通常使用类型提示。这是在 Python 3.5 中引入的。从 3.5 开始，我们可以指定类型，但这是比较麻烦的。 这项更新真正改变了这一点，现在可以将内置集合类型（List 和 Dict）用作泛型类型。 之前，必须通过输入来调用大写类型 List 和 Dict。 ef greet_all(names: list[str]) -&gt; None:for name in names:print(&quot;Hello&quot;, name) 现在，无需从 typing.List 来调用 List 4、新的数学函数 数学模块添加和改进了许多辅助功能，从对现有功能的改进开始。 以前计算最大公因数的 gcd 函数只能应用于 2 个数字，迫使程序员在处理更多数字时必须执行类似 math.gcd（80，math.gcd（64，152））的操作。从 Python 3.9 开始，我们可以将其应用于任意数字的值。 math 模块中第一个新添加的是 math.lcm 函数： math.lcm 计算其参数的最小公倍数。与 GCD 一样，它允许可变数量的参数。 5、新的解析器 这部分更多是视线之外的改变，但有可能成为 Python 未来发展中最重大的改变之一。 Python 3.9 使用了一个新的基于 PEG 的解析器。以前 Python 使用 LL（1），在构建该语言的新功能时，PEG 比 LL（1）更灵活。官方文档中表示，这种灵活性将在 Python 3.10 及更高版本中体现出来。 ast 模块使用新的解析器，并产生与旧解析器相同的 AST。 6、IPv6 范围内的地址 Python 3.9 的另一个变化是可以指定 IPv6 地址的范围。IPv6 范围用于指定相应 IP 地址在 Internet 的哪个部分有效。 范围可以使用％符号在 IP 地址的末尾指定——例如：3FFE：0：0：1：200：F8FF：FE75：50DF％2——因此该 IP 地址在范围 2 中，即链接本地地址。 因此，如果需要使用 Python 处理 IPv6 地址，现在可以这样处理： from ipaddress import IPv6Addressaddr = IPv6Address(&#x27;ff02::fa51%1&#x27;)print(addr.scope_id) 7、新模块：区域信息 区域信息 zoneinfo 模块将 IANA 时区数据库的支持引入标准库。它添加了 zoneinfo.ZoneInfo，这是一个由系统时区数据支持的具体的 datetime.tzinfo 实现。 8、其他语言更改 __import __（）现在增加了 ImportError 以替代 ValueError，通常在相对导入超出其顶级包时发生。 “” .replace（“”，s，n）现在对于所有非零 n 返回 s 而不是空字符串。现在它与 ““ .replace（”“，s）相一致。 默认状态下，Python 变得更快 Python 的每个修订版与以前的版本相比都有性能改进。Python 3.9 进行了两项重大改进，可以提高性能但无需对现有代码进行任何更改。 第一个改进更多涉及矢量调用协议的使用，通过最小化或消除临时对象进行许多常见函数的调用。Python 3.9 引入了几个新的内置函数，包括 range、tuple、set、frozenset、list、dict ——使用 vectorcall 可以加快执行速度。 Python 切换到年度发布周期 到目前为止，Python 已经以 18 个月的节奏进行了开发和发布。PEP 602 提议 Python 开发团队采用年度发布周期，并且该提议已被接受。","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"程序开发/Python","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://norhub.com.cn/tags/python/"}]},{"title":"HTML5和CSS3有哪些新增内容","slug":"HTML5和CSS3有哪些新增内容","date":"2020-11-19T09:22:35.000Z","updated":"2021-06-03T03:39:26.000Z","comments":true,"path":"2020/11/19/HTML5和CSS3有哪些新增内容/","link":"","permalink":"http://norhub.com.cn/2020/11/19/HTML5%E5%92%8CCSS3%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E5%A2%9E%E5%86%85%E5%AE%B9/","excerpt":"","text":"html5是超文本标记语言（HTML）的第五次重大修改，有全新的元素，属性和行为 H5新增内容 语义化标签 &lt;header&gt; :头部标签 &lt;nav&gt; :导航标签 &lt;article&gt; :内容标签 &lt;section&gt; :块级标签 &lt;aside&gt; :侧边栏标签 &lt;footer&gt; :尾部标签 语义化标签主要针对搜索引擎 可以在页面中使用多次 在ie9中，需要把这些元素转换为块级元素 移动端更喜欢用这些标签 多媒体标签 &lt;audio&gt; :音频 &lt;video&gt; :视频 表单属性 type=&quot;email&quot; :限制用户输入为email类型 type=&quot;url&quot; :限制用户输入为url类型 type=&quot;date&quot; :限制用户输入为日期类型 type=&quot;time&quot; :限制用户输入为时间类型 type=&quot;month&quot; :限制用户输入为月类型 type=&quot;week&quot; :限制用户输入为周类型 type=&quot;number&quot; :限制用户输入为数字类型 type=&quot;tel&quot; :手机号码 type=&quot;search&quot; :搜索框 type=&quot;color: :颜色选择表单 CSS3新增内容 属性选择器 E[att] :选择具有att属性的E元素 E[att=&quot;val&quot;] :选择具有att属性且值等于val的E元素 E[att^=&quot;val&quot;] :选择具有att属性且值以val开头的E元素 E[att$=&quot;val&quot;] :选择具有att属性且值以val结尾的E元素 E[att*=&quot;val&quot;] :选择具有att属性且值中含有val的E元素 属性选择器的权重是10 结构伪类选择器 E:first-child :匹配父元素中的第一个子元素E E:last-child :匹配父元素中的最后一个子元素E E:nth-child(n) :匹配父元素中的第n个子元素E E:first-of-type :指定类型E的第一个 E:last-of-type :指定类型E的最后一个 E:nth-of-type(n) :指定类型E的第n个 n可以是even(偶数)和odd(奇数),或者是公式2n(偶数)、2n+1(奇数)等 伪元素选择器 ::before :在元素内部的前面插入内容 ::after :在元素内部的后面插入内容 必须有content属性，属于行内元素，权重为1 2d转换 transition: all 0.3s; 动画过渡 transform: translate(x,y); #移动到新位置，不影响其他元素位置 transform: translate(50%,50%); #移动到新位置，自身宽度的一半 transform: rotate(45deg); #顺时针旋转45度，角度为负数时是逆时针旋转 transform-origin: left bottom; #转换中心点，可以用方位词像素和百分比 transform: scale(x,y); #缩放，使用没有单位的数字参数作为缩放倍数 同时添加多个转换，中间用空格隔开，先后顺序会影响转换的结果。有位移和其他属性时，要把位移放在最前面 动画 使用keyframes定义动画 @keyframes 动画名称 &#123; 0%&#123; width:100px; &#125; 100%&#123; width:200px; &#125;&#125; 元素使用动画 div &#123; width: 200px; height: 200px; background-color: aqua; margin: 100px auto; animation-name: 动画名称； animation-duration: 持续时间；&#125; @keyframes :规定动画 animation :所有动画属性的简写 animation-name :规定@keyframes的动画名称（必要） animation-duration :规定动画完成的周期，默认是0（必要的） animation-timing-function :规定动画速度曲线，默认是&quot;ease&quot; animation-delay :规定动画何时开始，默认是0 animation-iteation-count :规定动画播放的次数，默认是1，还有infinite animation-direcition :规定动画是否在下一周期逆向播放，默认是&quot;normal&quot; animation-play-state :规定动画是否正在运行或暂停。默认是&quot;running&quot;还有&quot;paused&quot; animation-fill-mode :规定动画结束后状态，保持forwards回到起始backwards 动画简写属性： animation :动画名称 持续时间 运动曲线 何时播放 播放次数 是否反向 动画起始或结束状态 animation: myfirst 5s linear 2s infinite alternate; 3D转换 3d移动 transform:translateX(100px); transform:translateY(100px); transform:translateZ(100px);在z轴移动，单位px transform:translate3d(x,y,z);其中x,y,z分别表示要移动的方向的距离 透视 perspective:100px;给要透视元素的父盒子添加透视效果,有透视才能看到3d效果 旋转 transform:rotateX(45deg); transform:rotateY(45deg); transform:rotateZ(45deg);沿着z正向旋转45度 transform:rotate3d(x,y,z,deg);沿着自定义轴旋转，deg为角度 3d呈现 transform-style:flaat;默认值，子元素不开启3d立体空间 transform-style:preserve-3d; 子元素开启立体空间 控制字元素是否开启3d环境，属性指定给父元素但影响的是子元素 浏览器的私有前缀 浏览器私有前缀是兼容老版本写法，新版本浏览器无需添加 -moz-: 代表firefox浏览器私有属性 -ms-: 代表ie浏览器私有属性 -webkit-:代表safari、chrome私有属性 -o-:代表Opera私有属性 使用方法: -o-border-radius:10px;","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"HTML","slug":"程序开发/HTML","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/HTML/"}],"tags":[{"name":"css","slug":"css","permalink":"http://norhub.com.cn/tags/css/"},{"name":"html","slug":"html","permalink":"http://norhub.com.cn/tags/html/"}]},{"title":"如何使用CSS3加DIV布局","slug":"如何使用CSS3加DIV布局","date":"2020-10-31T10:31:59.000Z","updated":"2021-06-03T03:40:21.000Z","comments":true,"path":"2020/10/31/如何使用CSS3加DIV布局/","link":"","permalink":"http://norhub.com.cn/2020/10/31/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CSS3%E5%8A%A0DIV%E5%B8%83%E5%B1%80/","excerpt":"css基础知识 引入css的三种方法： 行类样式：&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt; 内部样式表：任意位置的&lt;style&gt;标签,推荐在头部定义 外部样式表：&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;","text":"css基础知识 引入css的三种方法： 行类样式：&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt; 内部样式表：任意位置的&lt;style&gt;标签,推荐在头部定义 外部样式表：&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt; css特性: 层叠性：样式就近原则，那个样式进就应用 继承性：子标签会继承父标签的某些样式 优先级：继承或* 0,0,0,0; 标签选择器 0,0,0,1; 类 0,0,1,0; ID 0,1,0,0; 行内样式：1,0,0,0; limportant 无穷大 css选择器： 标签选择器：p {} 类选择器：.class {} id选择器： #id {} 通配符选择器：* {} 复合选择器： 后代选择器：.nav a {} 子元素选择器： div&gt;strong {} 交集选择器：p.red {} 并集选择器：p,span,.red {} 链接伪类选择器：a:hover {}表示鼠标经过a标签 标签的显示模式： 块级元素：独占一行，高宽边距可控制，宽度默认是父级的100%，是容器里面能放行内和块元素 行内元素：一行多个，高宽不能设置，默认宽度就是它本身的宽度，行内元素只能放文本或者其他行内元素 行内块元素：一行多个，高宽边距可控制，默认宽度就是他本身内容的宽度 标签显示模式切换： 块转行：display:inline 行转块：display:block; 块和行转行内块：display:inline-block; emmet语法: 生成标签直接输入标签名，然后按tab 生成多个标签加*，div*3就是三个div标签 生成父子关系标签，ul&gt;li 生成兄弟关系标签，div+p 生成带类名或者带id的标签，.demo或者#two然后按tab键 生成自增顺序的类名标签，.demo$*3 样式说明 外观： color: 颜色 line-height: 行高 text-align: center; 文字水平居中对齐 text-align: right; 文字右对齐 text-indent: 首行缩进，2em是首行缩进两字符 text-decoration: 文本修饰，下划线underline,取消下划线none 字体： font-size: 字号 font-family: 字体 font-weight: 字体粗细，700或bold是加粗，400或normal是不加粗细，数字后面没有单位 font-style: 字体样式，italic是倾斜，normal是不倾斜 font:字体连写，字体连写有顺序，字号和字体必须同时出现 背景： background-color:背景颜色 background-image:none|url(url) 背景图片 background-repeat: repeal 背景平铺 background-repeat: no-repeal 背景不平铺 background-repeat: repeal-x 背景横向平铺 background-repeat: repeal-y 背景纵向平铺 background-position: right top; 背景位置右上角 background-position: x坐标 y坐标; 背景位置 background-position: left bottom; 背景位置左下角 background-position: center center; 背景位置水平垂直居中 background-position: center left; 如果是方位词，背景位置值的顺序无关 background-position: top; 只指定一个值，另一个默认居中 background-position: center 10px; 水平居中，垂直10 background-atachment: fixed; 背景固定 background-atachment: scoll; 背景滚动 backgroud: 背景颜色 背景图片 背景平铺 背景滚动 背景位置; 背景简写方式 backgroud: rgba(0,0,0,0.3); 背景透明 列表： list-style: none;去掉列表样式 float:left;浮动在一行 子元素不写样式也会继承父元素的一些样式，可以被继承的样式 font,line,text,color。 单行文本垂直居中 文字分为顶线中线和基线,上行基线到下行基线的距离就是行号。中文没有基线，就测两行底线之间的距离 盒子里的行高就是上距离加内容距离加下距离，行高等于盒子的高度就能实现文本垂直居中 盒子模型 边框样式 border-width: 5px; 边框宽度 border-style: dashed; 边框样式 border-color: pink; 边框颜色 border: 5px dotted pinkp; 边框简写 border: none; 边框去掉 border-top: 宽度 样式 颜色; 上边框 border-bottom: 宽度 样式 颜色; 下边框 border-left: 宽度 样式 颜色; 左边框 border-right: 宽度 样式 颜色; 右边框 border-collapse:collapse; 合并边框，表格边框会叠加，合并后就是细线表格 border-radius:50%; 高度的一半,圆角边框 圆角边框 border-radius: 20px 20px 20px 20px; 圆角边框简写，左上 右上 右下 左下 border-top-left-radius:20px; 按顺序设置可以分别设置四个角，左上 右上 左下 右下 border-top-right-radius:20px; border-bottom-left-radius:20px; border-bottom-right-radius:20px; 内边距 padding-left: 左内边距 padding-right: 右内边距 padding-top: 上内边距 padding-bottom: 下内边距 padding: 10px 10px 10px 10px;上右下左的内边距简写 padding: 10px;上右下左的内边距简写 padding: 10px 10px;上下和左右内边距简写 padding: 10px 10px;上和左右和下内边距简写 内边距会撑大盒子增加盒子宽度，没有宽度的盒子指定内边距则不会撑开盒子。比如父盒子指定了宽度子盒子不指定宽度设置内边距是和父盒子一样宽的，如果子盒子指定了宽度再给内边距则会撑破父盒子（比父盒子宽） 外边距 margin: 10px; marrgin-top: 50px; margin: 0 auto; 块级盒子居中对齐，注意盒子要设置宽度 盒子阴影 box-shadow: 水平阴影 垂直阴影 模糊 影子大小 阴影颜色 内/外阴影; box-shadow: 0 15px 30px rgb(0,0,0,.3); 元素默认就有内外边距，清除内外边距： * &#123; padding:0; margin:0;&#125; 行内元素为了兼容性，尽量只设置左右内外边距 外边距的合并 两个上下相邻的盒子设置了外边距，则取两个值中的较大者合并，这叫外边距塌陷现象 垂直的外边距合并，两个嵌套关系的块元素，如果父元素没有上内边距及边框。父元素的上外边距会与子元素的上外边距合并，合并为两者中的较大值 盒子有浮动或者绝对定位（固定定位）属性也能解决外边距合并的问题 盒子模型的稳定性 根据盒子模型稳定性，建议优先使用宽度，其次内边距，再次外边距 width &gt; padding &gt; margin 布局 浮动 css布局的三种机制 普通流（标准流） 块级元素会独占一行，从上往下排列 常用元素：div,hr,p,h1~h6,ul,ol,dl,form,table 行类元素按照顺序从左到右排列 常用元素：span,a,i,em 浮动 让盒子从普通流中浮起来，主要用于让多个块级盒子一行显示 定位 将盒子定在浏览器的某一位置 浮动的作用 让多个盒子水平排列成一行，使浮动成为布局重要手段。 可以实现盒子的左右对齐等 浮动控制图片，实现文字环绕 float: none/left/right; 不浮动和左浮动右浮动 浮动列表元素 实际使用的导航栏中，我们不会用标签a而是用li包含连接(li+a)的做法 li+a语义清晰，一看就是有条理的列表型内容 如果直接用a,搜索引擎容易辨别为有堆砌关键字的嫌疑（故意堆砌关键字容易被搜索引擎有降权的风险），从而影响网站排名 清除浮动 父级盒子很多情况下，不方便给高度，但是子盒子浮动就不占有位置，最后父盒子高度为0，就影响了下面的标准流盒子 清除浮动就是为了解决父级元素因为子级浮动引起的内部高度为0的问题。清除后父级就会根据浮动盒子自动检测高度。父级有了高度就不会影响下面的标准流了 额外标签法清除浮动，在最后一个浮动标签后面添加一个不浮动的div标签,样式写clear:both 浮动标签的父级样式添加:overflow:hidden|auto|scroll 都可以实现清除浮动，该样式是溢出样式隐藏 使用after伪元素清除浮动，给父级添加以下样式就能清除浮动 使用双伪元素清除浮动，给父级添加以下样式就能清除浮动 什么时候清除浮动 父级没高度 子盒子浮动了 影响下面布局了 CSS属性书写顺序 布局定位属性： display/position/float/clear/visibility/overflow (display第一个写，关系到模式) 自身属性：width/height/margin/padding/border/background 文本属性：color/font/text-decoration/text-align/vertical-align/white-space/break-word 其他属性（CSS3）：content/cursor/border-radius/box-shadow/text-shadow/background:linear-gradiennt ... 布局流程 必须确定页面的版心（可视区），我们测量可知。 分析页面中的行模块，以及每个行模块中的列模块。其实页面布局，就是一行一行罗列而成 制作HTML结构，要遵循现有结构后有样式的原则。结构永远最重要。 开始运用盒子模型的原理，通过DIV+CSS布局来控制网页的各个模块。 定位 边偏移 定位的盒子要通过边偏移来移动位置，定位的盒子有边偏移才有价值，一般有定位的地方就有边偏移 top:80px; 顶端偏移量，定义元素相对于其父元素上边线的距离 bottom:80px; 底部偏移量，定义元素相对于其父元素下边线的距离 left:80px; 左侧偏移量，定义元素相对于其父元素左边线的距离 right:80px; 右侧偏移量，定义元素相对于其父元素右边线的距离 定位模式 在不同情况下要用到不同的定位模式 position: static; 静态定位,默认模式相当于none,不要定位的时候用 position: relative; 相对定位，相对于原来在标准流中的位置来移动，在原有标准流的区域继续占有（保留位置） position: absolute; 绝对定位，绝对定位以父级位置来移动，父级没有定位就以浏览器为准（不保留位置） position: fixed; 固定定位，以浏览器可视窗口为准固定位置，不随滚动条滚动而滚动，不保留原位置 父级要占有位置，子级要任意摆放，所以经常要使父级相对定位，子级绝对定位（子绝父相） 绝对定位居中对齐，先让盒子左侧移动到父级的水平中心位置，再让盒子向左移动自身宽度的一半 固定定位居中对齐，width:100%加text-align:center是通栏居中对齐 堆叠顺序z-index，在使用定位时可能会出现盒子重叠，加了定位的盒子后面的盒子会压住前面的盒子，可以用z-index层叠等级改变盒子的堆叠顺序 z-index 取值可以是正负数或0，数值越大，盒子越靠上 如果取值相同，则按书写顺序，后来居上 取值后面没有单位 定位会改变display属性，display是显示模式，可以改变显示模式的方法有 可以用inline-block转换为行内块 可以用浮动float默认转换行内块（类似行内块，并不完全一样，因为浮动是脱标的） 绝对定位和固定定位也和浮动类似，默认转换为行内块 css高级技巧 元素的显示与隐藏 display设置或检索对象如何显示，不保留位置 display:nono; 隐藏对象 display:block; 除了转换为块元素，同时还有显示元素的意思 visibility设置对象隐藏,保留位置 visibility:hidden; 隐藏 visibility:visible; 显示 overflow检索或设置对象超出其指定高宽时如何管理内容 overflow:visible; 不隐藏内容也不显示滚动条 overflow:hidden; 超出部分隐藏 overflow:scroll; 不管内容是否超出，总是显示滚动条 overflow:auto; 超出自动显示滚动条 overflow可以清除浮动，可以保证盒子的内容不会超出盒子 css用户界面样式 鼠标样式cursor,属性：default 默认、pointer 小手、move 移动、text 文本、not-allowed 禁止 轮廓线outline 用于绘制元素周围的一条线，在边框的外围，可起到突出元素的作用。 outline: outline-color | outline-style | outline-width; 常用的方式是：outline:0; 或者 outline:none 防止拖拽文本域，让textarea标签右下角不可拖拽 resize:none; 垂直居中 vertical-align垂直对齐，只针对于行内元素和行内块元素 基于文本的四条线设置垂直对齐 vertical-align:baseline | top | middle | bottom 主要用于控制文字和图片和表单之间垂直对齐关系 文字和图片默认是基线对齐，所以图片底侧会产生空白,改成其他对齐方式就能去除图片底侧空白，或者把图片转换成块元素也能去除 文本溢出省略 /*先强制一行内显示文本*/white-space: nowrap;/*超出部分隐藏*/overflow: hidden;/*用省略号替代超出部分*/text-overflow: ellipsis; 精灵技术 精灵是将网页中的多个背景图像整合到一张图中，减少服务器请求图片次数。网页中只需要精灵图中的某个小图。 精确测量图标在精灵图的位置和大小，先设置盒子宽高，然后利用背景位置（background-position）确定精灵图位置 滑动门技术，可以让特殊形状的背景图自适应元素内容，使背景图可以自由拉伸滑动。 利用精灵图设置文本的左侧背景和右侧背景，设置padding拉伸，实现滑动门 负值 利用margin负值让盒子边框相交的部分变细 float: left;margin-left: -1px 如果要鼠标经历过突出边框，就要用到定位 三角形 使用css边框模拟三角形，宽度高度要为0。四个边框都写，保留需要的边框颜色，其他位置边框颜色是透明（rransparent）。为了兼容性要设置font-size:0;line-height:0;","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"HTML","slug":"程序开发/HTML","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/HTML/"}],"tags":[{"name":"css","slug":"css","permalink":"http://norhub.com.cn/tags/css/"},{"name":"div","slug":"div","permalink":"http://norhub.com.cn/tags/div/"}]},{"title":"Linux基础命令的使用","slug":"Linux基础命令的使用","date":"2020-10-07T03:49:29.000Z","updated":"2021-05-13T01:58:35.000Z","comments":true,"path":"2020/10/07/Linux基础命令的使用/","link":"","permalink":"http://norhub.com.cn/2020/10/07/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"终端的使用 终端使用快捷键: ctrl + shift + = 放大字体 ctrl + - 缩小字体 终端使用技巧: tab键: 自动补全 上下键: 切换曾经使用的命令 终端命令格式:command [-options] [paraneter] 说明： command: 命令名 [-options]: 选项，对命令控制，可省略 [paraneter]: 传给命令的参数，可以是一个多个或者没有","text":"终端的使用 终端使用快捷键: ctrl + shift + = 放大字体 ctrl + - 缩小字体 终端使用技巧: tab键: 自动补全 上下键: 切换曾经使用的命令 终端命令格式:command [-options] [paraneter] 说明： command: 命令名 [-options]: 选项，对命令控制，可省略 [paraneter]: 传给命令的参数，可以是一个多个或者没有 查阅帮助： command --help 查看手册： man command 空格键: 显示手册下一屏 enter键: 一次滚动手册的一行 b: 回滚一屏 f: 前滚一屏 q: 退出 文件目录常用命令 ls # 查看文件夹内容ls -a # 显示所有文件，包括隐藏的ls -h # 配合-l人性化显示文件大小ls -l # 列表显示文件详情pws # 查看所在文件夹cd [目录名] # 切换文件夹，却对路径以/或者~开头cd . # .表示当前目录cd .. # ..表示上一级目录cd ~ # ~表示家目录，也可以直接cd回到家目录cd - # 在最近两次目录切换touch [文件名] # 文件不存在就新建文件，存在就修改文件修改日期mkdir [目录名] # 创建目录mkdir -p [目录名] # 递归创建目录rm [文件名] # 删除文件rm -f [文件名] # 强制删除，不提示rm -r [目录名] # 递归删除，删除文件夹rm -rf * # 使用通配符，当前目录的文件全部删除tree # 树状图的方式看目录tree -d # 只看目录不看文件cp [源文件] [目标文件] # 拷贝文件cp -i [源文件] [目标文件] # 覆盖文件前提示cp -r [源文件] [目标文件] # 递归复制目录mv [源文件] [目标文件] # 移动文件mv -r [源文件] [目标文件] # 覆盖前提示cat # 查看文件内容cat -b # 对非空输出行编号cat -n # 对所有行编号more # 分屏查看文件 分配查看文件时的操作 空格键: 显示手册下一屏 enter键: 一次滚动手册的一行 b: 回滚一屏 f: 前滚一屏 q: 退出 /word: 搜索word字符 grep as 123.txt # 在123.txt文件中搜索asgrep -n as 123.txt # 显示匹配行和行号grep -i as 123.txt # 忽略大小写grep -i &quot;as is&quot; 123.txt # 如果有空格要用引号grep -v as 123.txt # 显示不匹配的行grep ^a 123.txt # 模式匹配，正则表达式，以a开头的行echo # 在终端显示内容&gt; # 重定向，将命令执行结果重定向到一个文件echo Hello &gt; b # 在b文件中添加内容Hello&gt;&gt; # 重定向追加内容| # 管道，允许一个目录的输出通过管道作为另一个文件的输入ls -lha ~ | more # 把用户目录分屏显示ls -lha ~ | grep Do # 查询用户目录，文件包含Do的 常用的通配符 *表示任意个数字符 ?表示任意一个字符 []表示匹配字符组中的一个 [abc]匹配abc中的一个 [a-f]匹配a-f中的一个 ls ?2*1.txt # 这个命令查看以任意一个字符和2开头，以1结尾的txt文件 ls [135]23.txt # 查看以135开头的文件 远程管理命令 clear # 清屏shutdown # 关机shutdown -r # 重启shutdown -r now # 马上重启ifconfig # 查看网卡配置ping # 检测到目标ip的连接是否正常ssh -p [端口号] [用户名]@[ip域名或别名] # 远程连接服务器,端口是22就可以省略-pscp # 远程拷贝文件scp -P port 01.py user@renote:Desktop/01.py # 把本地当前目录的01.py上传到远程家目录的Desktop/01.py，-P要大写scp -r user@renote:Desktop/demo # 把远程家目录的demo文件夹拷贝到本地，操作文件夹用-rssh-copy-id root@192.168.2.1 # 拷贝公钥到192.168.2.1，让那台机器可以免密登录我的机器 用户权限 chmod -rwx data.txt # 移除可读可写可执行chmod +rwx data.txt # 增加可读可写可执行sudo [命令] # 切换其他用户执行命令，默认是root 组管理 groupadd 组名 # 添加组groupdel 组名 # 删除组cat /etc/group # 查看组chgrp -R 组名 文件/目录名 # 递归修改文件夹或文件所属组 用户管理 useradd -m -g [组] [新建用户名] # 添加新用户，-m自动建立用户家目录，-g指定用户所属组，默认在同名用户名组passwd [用户名] # 设置或修改用户密码userdel -r [用户名] # 删除用户，-r自动删除用户家目录cat /etc/passwd | grep [用户名] # 确认用户信息，新的用户信息会保存在/etc/paswd文件中 /etc/paswd文件中存放的是用户信息，由6个分号组成的七个信息，分别是 用户名 密码（x,表示加密的密码） UID(用户标识) GID(组标识) 用户全名或本地账号 家目录 登录使用的shell,就是登录后使用的终端命令，ubuntu默认是dash id 用户名 # 显示用户id和组idwho # 查看当前所有登录的用户列表whoami # 查看当前登录用户的用户名usermod -g [组] [用户名] # 修改用户主组,主组是新建用户时指定的usermod -G [组] [用户名] # 修改用户附加组，附加组是指定用户的附加权限usermod -G sudo [用户名] # 将用户添加都sudo组，可以使用root身份执行命令usermod -s /bin/bash # 修改用户登录shell，默认是dash要修改成bash,bash更方便，目录有颜色，按上键也不会输入字符which # 查看执行命令所在的目录which useradd # 查看用户密码在的目录which ls # 查看ls命令在的目录 bin和sbin 在linux中，大多数可执行文件都保存在/bin、/sbin、/usr/bin、/usr/sbin /bin 二进制执行文件目录，主要用于具体应用 /sbin 是系统管理员专用的二进制代码存放目录，主要用于系统管理 /usr/bin 后期安装的一些软件 /usr/sbin 超级用户的一些管理程序 su - [用户名] # 切换用户，-表示可以切换到用户家目录，否则位置不变exit # 退出当前用户chown [用户名] [文件名|目录名] # 修改文件或目录的拥有者chgrp -R [组名] [文件名|目录名] # 递归修改所属组，-R表示递归修改所有子目录和文件的组chmod -R 775 [文件名|目录名] #修改权限，三个数字分别对应：拥有者/组/其他，用户的权限 数字对应的权限 拥有者 组 其他 r w x r w x r w x 4 2 1 4 2 1 4 2 1 系统信息 date # 查看系统时间cal # 查看日历，-y可以看一年的日历df -h # 显示磁盘剩余空间，-h以人性化的方式显示文件大小du -h [目录名] # 显示目录下的文件大小ps aux # 查看进程使用情况，a显示所有进程包括其他用户的，u显示进程详细状态，x显示没有控制终端的进程一般不使用该选项top # 动态显示进程并排序，按q退出kill -9 [进程代号] # 结束进程，-9表示强制结束 其他命令 find [路径] -name &quot;*.py&quot; # 查找指定路径下以py结尾的文件，包括子目录。不写路径就是当前路径Ln -s [被链接的源文件] [链接文件] # 创建软链接类似快捷方式，源文件使用文件绝对路径，链接文件随便起名Ln [被链接的源文件] [链接文件] # 硬链接，源文件被删除链接文件不受影响 打包压缩 tar -cvf [打包文件.tar] [被打包的文件|路径] # 打包文件，-c创建打包文件，-v列出详细过程、进度，-f指定文件名。f选项后面一定是tar文件，所以必须放选项最后面tar -xvf [打包文件.tar] # 接包文件，-x解开打包文件tar -zcvf [打包文件.tar.gz] [被压缩的文件|路径] # 压缩文件，-z调用gzip对文件压缩tar -zxvf [打包文件.tar.gz] -C [目标路径] # 解压文件， -C解压到指定目录，目录必须存在tar -jcvf [打包文件.tar.bz2] [被压缩的文件|路径] # 压缩文件，-j调用bzip2对文件压缩tar -jxvf [打包文件.tar.bz2] -C [目标路径] # 解压文件， -C解压到指定目录，目录必须存在 软件安装 # 安装软件sudo apt install [软件包]# 卸载软件sudo apt remove [软件名]# 更新已安装的包sudo apt upgrade# 一个小火车提示sudo apt install sl# 一个比较漂亮的查看当前进程排名的软件sudo apt install htop","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Linux","slug":"程序开发/Linux","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://norhub.com.cn/tags/linux/"}]},{"title":"使用Docker安装常用数据库","slug":"使用Docker安装常用数据库","date":"2020-09-07T08:51:05.000Z","updated":"2021-04-30T02:53:19.000Z","comments":true,"path":"2020/09/07/使用Docker安装常用数据库/","link":"","permalink":"http://norhub.com.cn/2020/09/07/%E4%BD%BF%E7%94%A8Docker%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"使用Docker搭建Mysql服务 拉取官方镜像,不写后面的版本号则会自动拉取最新版 docker pull mysql:5.7 # 拉取 mysql 5.7","text":"使用Docker搭建Mysql服务 拉取官方镜像,不写后面的版本号则会自动拉取最新版 docker pull mysql:5.7 # 拉取 mysql 5.7 检查是否拉取成功 sudo docker images 直接启动容器 sudo docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 –name：容器名，此处命名为mysql -e：配置信息，此处配置mysql的root用户的登陆密码 -p：端口映射，此处映射 主机3306端口 到 容器的3306端口 如果要建立目录映射 suso docker run -p 3306:3306 --name mysql \\-v /usr/local/docker/mysql/conf:/etc/mysql \\-v /usr/local/docker/mysql/logs:/var/log/mysql \\-v /usr/local/docker/mysql/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=123456 \\-d mysql:5.7 检查容器是否正确运行 docker container ls 如果无法访问到MySQL，需要允许通过防火墙 # 开放端口：systemctl status firewalldfirewall-cmd --zone=public --add-port=3306/tcp -permanentfirewall-cmd --reload# 或者关闭防火墙：sudo systemctl stop firewalld 进入docker本地客户端设置远程访问账号 sudo docker exec -it mysql bashmysql -uroot -p123456mysql&gt; use mysql;mysql&gt; grant all privileges on *.* to root@&#x27;%&#x27; identified by &quot;password&quot;;mysql&gt; flush privileges;mysql&gt; select host,user,password from user; 现在可以通过以下信息连接到mysql了 host: 127.0.0.1port: 3306user: rootpassword: 123456 使用Docker搭建Sql Server服务 从 Microsoft 容器注册表中拉取 SQL Server 2019 Linux 容器映像 sudo docker pull mcr.microsoft.com/mssql/server:2019-CU5-ubuntu-18.04 使用命令提示符使用以下命令运行容器映像 sudo docker run -e &quot;ACCEPT_EULA=Y&quot; -e &quot;SA_PASSWORD=&lt;YourStrong@Passw0rd&gt;&quot; \\ -p 1433:1433 --name sql1 \\ -d mcr.microsoft.com/mssql/server:2019-CU5-ubuntu-18.04 -e &quot;ACCEPT_EULA=Y&quot; 将 ACCEPT_EULA 变量设置为任意值，以确认接受最终用户许可协议。 SQL Server 映像的必需设置。 -e &quot;SA_PASSWORD=&lt;YourStrong@Passw0rd&gt;&quot; 指定至少包含 8 个字符且符合 SQL Server 密码要求的强密码。 SQL Server 映像的必需设置。 -p 1433:1433 将主机环境中的 TCP 端口（第一个值）映射到容器中的 TCP 端口（第二个值）。 在此示例中，SQL Server 侦听容器中的 TCP 1433，并对主机上的端口 1433 公开。 --name sql1 为容器指定一个自定义名称，而不是使用随机生成的名称。 如果运行多个容器，则无法重复使用相同的名称。 mcr.microsoft.com/mssql/server:2019-CU5-ubuntu-18.04 SQL Server 2019 Ubuntu Linux 容器映像。 使用 docker exec 运行sqlcmd，以使用 Transact-SQL 更改密码。 在下面的示例中，将旧密码 &lt;YourStrong!Passw0rd&gt; 和新密码 &lt;YourNewStrong!Passw0rd&gt; 替换为你自己的密码值。 sudo docker exec -it sql1 /opt/mssql-tools/bin/sqlcmd \\ -S localhost -U SA -P &quot;&lt;YourStrong@Passw0rd&gt;&quot; \\ -Q &#x27;ALTER LOGIN SA WITH PASSWORD=&quot;&lt;YourNewStrong@Passw0rd&gt;&quot;&#x27; 参考：https://docs.microsoft.com/zh-cn/sql/linux/quickstart-install-connect-docker?view=sql-server-ver15&amp;pivots=cs1-bash 使用Docker搭建Oracle11g服务 下载的过程较长，镜像6.8G docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g 创建容器 docker run -d -p 1521:1521 --name oracle11g registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g 启动容器 docker start oracle11g 进入镜像进行配置 docker exec -it oracle11g bash 切换root用户，密码：helowin su root 编辑profile文件配置ORACLE环境变量 export ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_2 export ORACLE_SID=helowin export PATH=$ORACLE_HOME/bin:$PATH 创建软连接 ln -s $ORACLE_HOME/bin/sqlplus /usr/bin 登录sqlplus并修改sys、system用户密码 su - oraclesqlplus /nologconn /as sysdba# 打开数据库alter database mount;alter database open;# 修改密码alter user system identified by system;alter user sys identified by sys;exit 修改 tnsnames.ora的 service_name=helowinXDB docker_oracle11 = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.211.135)(PORT =1521)) ) (CONNECT_DATA = (SERVICE_NAME = helowinXDB) )) 启用监听 lsnrctl status","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Docker","slug":"程序开发/Docker","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://norhub.com.cn/tags/docker/"}]},{"title":"Linux出现Read-onlyFileSystem错误的解决方法","slug":"Linux出现Read-onlyFileSystem错误的解决方法","date":"2020-09-01T06:10:57.000Z","updated":"2021-05-21T05:36:20.000Z","comments":true,"path":"2020/09/01/Linux出现Read-onlyFileSystem错误的解决方法/","link":"","permalink":"http://norhub.com.cn/2020/09/01/Linux%E5%87%BA%E7%8E%B0Read-onlyFileSystem%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"造成这个问题的原因大多数是因为非正常关机后导致文件系统受损引起的，在系统重启之后， 受损分区就会被Linux自动挂载为只读。解决的方法是通过fsck来修复文件系统，然后重启即可。","text":"造成这个问题的原因大多数是因为非正常关机后导致文件系统受损引起的，在系统重启之后， 受损分区就会被Linux自动挂载为只读。解决的方法是通过fsck来修复文件系统，然后重启即可。 解决方法 查看系统分区 df -lh 修复文件系统 fsck -y /dev/sda2 临时解决 报错read-only file system的原因是你所在的分区只有读权限，没有写权限。 mount为挂载分区命令，重新挂载分区并增加读写权限即为 -rw。 比如提示data目录只读，可通过如下命令，将目标目录临时变更为可读写模式 mount -o remount rw /data","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Linux","slug":"程序开发/Linux","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://norhub.com.cn/tags/linux/"}]},{"title":"使用CentOS7安装MySql","slug":"使用CentOS7安装MySql","date":"2020-08-05T01:29:05.000Z","updated":"2021-06-03T03:32:04.000Z","comments":true,"path":"2020/08/05/使用CentOS7安装MySql/","link":"","permalink":"http://norhub.com.cn/2020/08/05/%E4%BD%BF%E7%94%A8CentOS7%E5%AE%89%E8%A3%85MySql/","excerpt":"安装mysql 下载并安装MySQL官方的 Yum Repository wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpmyum -y install mysql57-community-release-el7-10.noarch.rpm 执行安装命令 yum -y install mysql-community-server","text":"安装mysql 下载并安装MySQL官方的 Yum Repository wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpmyum -y install mysql57-community-release-el7-10.noarch.rpm 执行安装命令 yum -y install mysql-community-server 使用国内镜像安装 去国内镜像站下载client和server包 http://uni.mirrors.163.com/mysql/Downloads/ mysql-community-client-5.7.31-1.el7.x86_64.rpmmysql-community-server-5.7.31-1.el7.x86_64.rpm 上传到centos的/var/cache/yum/x86_64/7/mysql57-community/packages/ 再次执行安装 yum -y install mysql-community-server 设置mysql 开启MySQL服务 systemctl start mysqld.service 获取临时密码 grep &quot;password&quot; /var/log/mysqld.log 进入数据库 mysql -uroot -p 设置密码 # 修改密码验证规则mysql&gt; set global validate_password_policy=0;mysql&gt; set global validate_password_length=1;# 设置简单密码mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;# 开启mysql的远程访问mysql&gt; grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;password&#x27; with grant option;# 刷新mysql&gt; flush privileges;mysql&gt; exit; 防火墙开放端口 firewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --zone=public --add-port=8080/tcp --permanentfirewall-cmd --reload 更改mysql为utf-8 修改 mysql 配置文件 my.cnf vi /etc/my.cnf 在[client]段增加下面代码：default-character-set=utf8 在[mysql]段增加下面的代码：default-character-set=utf8 在[mysqld]段增加下面的代码：character-set-server=utf8 重启mysql服务器 service mysqld restart 查看字符编码 mysql -uroot -pmysql&gt; status; 安装python开发模块 cd /etc/yum.repos.d/rpm -ivh http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpmsudo yum install mysql-develsudo yum install python3-develpip install mysqlclient","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Linux","slug":"程序开发/Linux","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://norhub.com.cn/tags/linux/"},{"name":"centos","slug":"centos","permalink":"http://norhub.com.cn/tags/centos/"}]},{"title":"如何使用Ubuntu18安装Spark","slug":"如何使用Ubuntu18安装Spark","date":"2020-07-21T03:17:21.000Z","updated":"2021-06-03T01:16:10.000Z","comments":true,"path":"2020/07/21/如何使用Ubuntu18安装Spark/","link":"","permalink":"http://norhub.com.cn/2020/07/21/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Ubuntu18%E5%AE%89%E8%A3%85Spark/","excerpt":"Spark运行架构包括集群资源管理器（Cluster Manager）、运行作业任务的工作节点（Worker Node）、每个应用的任务控制节点（Driver）和每个工作节点上负责具体任务的执行进程（Executor）。其中，集群资源管理器可以是Spark自带的资源管理器，也可以是YARN或Mesos等资源管理框架。","text":"Spark运行架构包括集群资源管理器（Cluster Manager）、运行作业任务的工作节点（Worker Node）、每个应用的任务控制节点（Driver）和每个工作节点上负责具体任务的执行进程（Executor）。其中，集群资源管理器可以是Spark自带的资源管理器，也可以是YARN或Mesos等资源管理框架。 Scala的安装 因为Spark本身是以Scala开发的，所以必须先安装Scala. 2.4.x的spark -&gt;选择2.12.x的scala","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Linux","slug":"程序开发/Linux","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://norhub.com.cn/tags/ubuntu/"},{"name":"spark","slug":"spark","permalink":"http://norhub.com.cn/tags/spark/"}]},{"title":"Python模块psutil库的使用","slug":"Python模块psutil库的使用","date":"2020-07-17T08:44:47.000Z","updated":"2021-04-30T02:53:19.000Z","comments":true,"path":"2020/07/17/Python模块psutil库的使用/","link":"","permalink":"http://norhub.com.cn/2020/07/17/Python%E6%A8%A1%E5%9D%97psutil%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"psutil (python system and process utilities) 是一个跨平台的第三方库，能够轻松实现获取系统运行的进程和系统利用率（包扩CPU、内存、磁盘、网络等）信息。它主要用于系统监控、分析、限制系统资源和进程的管理。它实现了同等命令行工具提供的功能，如ps、top、lsof、netstat、ifconfig、who、df、kill、free、nice、ionice、iostat、iotop、uptime、pidof、tty、taskset、pmap","text":"psutil (python system and process utilities) 是一个跨平台的第三方库，能够轻松实现获取系统运行的进程和系统利用率（包扩CPU、内存、磁盘、网络等）信息。它主要用于系统监控、分析、限制系统资源和进程的管理。它实现了同等命令行工具提供的功能，如ps、top、lsof、netstat、ifconfig、who、df、kill、free、nice、ionice、iostat、iotop、uptime、pidof、tty、taskset、pmap 目前支持的操作系统包括：Linux,Windows,OSX,FreeBSD,OpenBSD,NetBSD,Sun Solaris,AIX 一、安装psutil库 pip install psutil 二、功能函数 1.1 CPU相关 函数 描述 psutil.cpu_count() 单元cpu_count(,[logical]):默认返回逻辑CPU的个数,当设置logical的参数为False时，返回物理CPU的个数 psutil.cpu_percent() cpu_percent(,[percpu],[interval])：返回CPU的利用率,percpu为True时显示所有物理核心的利用率,interval不为0时,则阻塞时显示interval执行的时间内的平均利用率 psutil.cpu_times() cpu_times(,[percpu])：以命名元组(namedtuple)的形式返回cpu的时间花费,percpu=True表示获取每个CPU的时间花费 psutil.cpu_times_percent() cpu_times_percent(,[percpu])：功能和cpu_times大致相同，看字面意思就能知道，该函数返回的是耗时比例 psutil.cpu_stats() cpu_stats()以命名元组的形式返回CPU的统计信息，包括上下文切换，中断，软中断和系统调用次数 psutil.cpu_freq() cpu_freq([percpu])：返回cpu频率 1.2 内存相关 函数 描述 virtual_memory() 以命名元组的形式返回内存使用情况，包括总内存，可用内存，内存利用率，buffer和cache等。单位为字节 swap_memory() 以命名元组的形式返回swap/memory使用情况，包含swap中页的换入和换出 1.3 磁盘相关 函数 描述 psutil.disk_io_counters() disk_io_counters([perdisk])：以命名元组的形式返回磁盘io统计信息(汇总的)，包括读、写的次数，读、写的字节数等。当perdisk的值为True，则分别列出单个磁盘的统计信息(字典：key为磁盘名称，value为统计的namedtuple) psutil.disk_partitions() disk_partitions([all=False])：以命名元组的形式返回所有已挂载的磁盘，包含磁盘名称，挂载点，文件系统类型等信息。当all等于True时，返回包含/proc等特殊文件系统的挂载信息 psutil.disk_usage() disk_usage(path)：以命名元组的形式返回path所在磁盘的使用情况，包括磁盘的容量、已经使用的磁盘容量、磁盘的空间利用率等 1.4 网络相关 函数 描述 psutil.net_io_counter([pernic]) 以命名元组的形式返回当前系统中每块网卡的网络io统计信息，包括收发字节数，收发包的数量、出错的情况和删包情况。当pernic为True时，则列出所有网卡的统计信息 psutil.net_connections([kind]) 以列表的形式返回每个网络连接的详细信息(namedtuple)。命名元组包含fd, family, type, laddr, raddr, status, pid等信息。kind表示过滤的连接类型，支持的值如下：(默认为inet) psutil.net_if_addrs() 以字典的形式返回网卡的配置信息，包括IP地址和mac地址、子网掩码和广播地址 psutil.net_if_stats() 返回网卡的详细信息，包括是否启动、通信类型、传输速度与mtu psutil.users() 以命名元组的方式返回当前登陆用户的信息，包括用户名，登陆时间，终端，与主机信息 psutil.boot_time() 以时间戳的形式返回系统的启动时间 1.5 进程管理 函数 描述 psutil.pids() 以列表的形式返回当前正在运行的进程 psutil.pid_exists(1) 判断给点定的pid是否存在 psutil.process_iter() 迭代当前正在运行的进程，返回的是每个进程的Process对象 psutil.Process() 对进程进行封装，可以使用该类的方法获取进行的详细信息，或者给进程发送信号 进程相关信息的方法 name：获取进程的名称 cmdline：获取启动进程的命令行参数 create_time：获取进程的创建时间(时间戳格式) num_fds：进程打开的文件个数 num_threads：进程的子进程个数 is_running：判断进程是否正在运行 send_signal：给进程发送信号，类似与os.kill等 kill：发送SIGKILL信号结束进程 terminate：发送SIGTEAM信号结束进程 三、使用实例 以下代码对系统信息进行监控，包括内存和cpu利用率，网速和监控时间 import psutil# 获取总内存大小memoryTotal = round(psutil.virtual_memory().total/(1024.0*1024.0*1024.0), 2)while True : # 设定30秒记录一次 time.sleep(30) # CPU使用率 cpuUsed = psutil.cpu_percent(1) # 内存信息 memoryInfo = psutil.virtual_memory() # 内存使用大小 memoryUsedSize = round(memoryInfo.used / (1024.0*1024.0*1024.0),2) # 内存使用率 memoryUsed = round(memoryUsedSize/memoryTotal,2)*100 # 或者直接查看使用率 psutil.virtual_memory().percent # 网络io统计信息 net = psutil.net_io_counters() # 接收字节 bytesRcvd = (net.bytes_recv / 1024) # 发送字节 bytesSent = (net.bytes_sent / 1024) # 过一秒再获取流量信息，算出每秒网速 time.sleep(1) net = psutil.net_io_counters() realTimeRcvd = round(((net.bytes_recv / 1024) - bytesRcvd),2) realTimeSent = round(((net.bytes_sent / 1024) - bytesSent),2) # 获取系统时间 tim = time.strftime(&#x27;%H:%M:%S&#x27;,time.localtime()) realTimeInfo = &#123; &#x27;cpu&#x27;:&#123;&#x27;cpuUsed&#x27;:cpuUsed&#125;, &#x27;memory&#x27;:&#123;&#x27;memoryUsed&#x27;:memoryUsed&#125;, &#x27;net&#x27;:&#123;&#x27;rcvd&#x27;:realTimeRcvd,&#x27;send&#x27;:realTimeSent&#125; &#x27;time&#x27;:tim &#125; print(realTimeInfo) 输出情况示例 &#123;&#x27;memory&#x27;: &#123;&#x27;memoryUsed&#x27;: 37.0&#125;, &#x27;cpu&#x27;: &#123;&#x27;cpuUsed&#x27;: 6.0&#125;, &#x27;net&#x27;: &#123;&#x27;send&#x27;: 2.89, &#x27;rcvd&#x27;: 6.52&#125;, &#x27;time&#x27;: &#x27;17:49:58&#x27;&#125;&#123;&#x27;memory&#x27;: &#123;&#x27;memoryUsed&#x27;: 37.0&#125;, &#x27;cpu&#x27;: &#123;&#x27;cpuUsed&#x27;: 3.8&#125;, &#x27;net&#x27;: &#123;&#x27;send&#x27;: 1.58, &#x27;rcvd&#x27;: 0.83&#125;, &#x27;time&#x27;: &#x27;17:50:30&#x27;&#125;&#123;&#x27;memory&#x27;: &#123;&#x27;memoryUsed&#x27;: 37.0&#125;, &#x27;cpu&#x27;: &#123;&#x27;cpuUsed&#x27;: 10.3&#125;, &#x27;net&#x27;: &#123;&#x27;send&#x27;: 1.71, &#x27;rcvd&#x27;: 0.12&#125;, &#x27;time&#x27;: &#x27;17:51:02&#x27;&#125;&#123;&#x27;memory&#x27;: &#123;&#x27;memoryUsed&#x27;: 37.0&#125;, &#x27;cpu&#x27;: &#123;&#x27;cpuUsed&#x27;: 5.1&#125;, &#x27;net&#x27;: &#123;&#x27;send&#x27;: 0.6, &#x27;rcvd&#x27;: 0.0&#125;, &#x27;time&#x27;: &#x27;17:51:34&#x27;&#125;&#123;&#x27;memory&#x27;: &#123;&#x27;memoryUsed&#x27;: 37.0&#125;, &#x27;cpu&#x27;: &#123;&#x27;cpuUsed&#x27;: 4.4&#125;, &#x27;net&#x27;: &#123;&#x27;send&#x27;: 1.43, &#x27;rcvd&#x27;: 4.8&#125;, &#x27;time&#x27;: &#x27;17:52:06&#x27;&#125;&#123;&#x27;memory&#x27;: &#123;&#x27;memoryUsed&#x27;: 37.0&#125;, &#x27;cpu&#x27;: &#123;&#x27;cpuUsed&#x27;: 4.7&#125;, &#x27;net&#x27;: &#123;&#x27;send&#x27;: 0.92, &#x27;rcvd&#x27;: 1.02&#125;, &#x27;time&#x27;: &#x27;17:52:38&#x27;&#125;&#123;&#x27;memory&#x27;: &#123;&#x27;memoryUsed&#x27;: 37.0&#125;, &#x27;cpu&#x27;: &#123;&#x27;cpuUsed&#x27;: 10.4&#125;, &#x27;net&#x27;: &#123;&#x27;send&#x27;: 0.75, &#x27;rcvd&#x27;: 0.06&#125;, &#x27;time&#x27;: &#x27;17:53:10&#x27;&#125;","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"程序开发/Python","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://norhub.com.cn/tags/python/"},{"name":"psutil","slug":"psutil","permalink":"http://norhub.com.cn/tags/psutil/"}]},{"title":"精准电量[Accubattery]Pro直装破解专业版","slug":"精准电量-Accubattery-Pro直装破解专业版","date":"2020-07-15T09:56:59.000Z","updated":"2021-06-03T02:01:32.000Z","comments":true,"path":"2020/07/15/精准电量-Accubattery-Pro直装破解专业版/","link":"","permalink":"http://norhub.com.cn/2020/07/15/%E7%B2%BE%E5%87%86%E7%94%B5%E9%87%8F-Accubattery-Pro%E7%9B%B4%E8%A3%85%E7%A0%B4%E8%A7%A3%E4%B8%93%E4%B8%9A%E7%89%88/","excerpt":"精准电量「Accubattery」Pro 是一款非常好用的电池健康检测维护管理软件，其基于一系列科学的研究和测试，能测试出设备电池的实际容量，并查看电池损耗，而且还可以通过设置充电到达百分数「Accubattery 建议是80%」提醒拔掉充电器，实现保护充电增加电池循环寿命，从而让您的电池保持健康。","text":"精准电量「Accubattery」Pro 是一款非常好用的电池健康检测维护管理软件，其基于一系列科学的研究和测试，能测试出设备电池的实际容量，并查看电池损耗，而且还可以通过设置充电到达百分数「Accubattery 建议是80%」提醒拔掉充电器，实现保护充电增加电池循环寿命，从而让您的电池保持健康。 专业版还有检测电池寿命、充放电速度、温度、电压等众多的功能。 特色功能： 电池健康。 电池的寿命是有限的。每次给装置充电，都会损耗电池，降低电池的总容量。科学研究表明，只将手机电池最多充到80%，能将电池寿命延长到200%。 通过使用我们的充电警告延长电池寿命。 发现充电中的电池损耗。 电池使用情况。 通过利用电池充电控制器提供的信息，AccuBattery可以测量出电池的实际使用情况 。将结果同在前台运行的应用信息相结合，可以确定每个应用的耗电量。Android测算电池耗电量是通过设备制造商提供的参数，比如，CPU消耗电多大。而实际上，这些测算值会有很大的偏差。 监控手机目前用电情况。 了解工作或待机状态下，手机能使用多长时间。 了解每个应用的耗电情况。 查看手机从休眠状态转为唤醒状态的频率。 充电速度。 用AccuBattery为手机找到最快的充电器和USB连接线。通过充电电流（以毫安为单位）来发现！ 查看手机显示屏开或关时的充电速度。 了解手机充电要多长时间，到几点钟可以充满。 专业版功能 实时CPU和电量使用情况叠加层，找出费电的进程。 通过深色和AMOLED黑主题来省电。 访问昨天之前的充电历史。 通知中详细的电池统计数据。 关于此破解专业版： 感谢国外kirlif大神的修改和分享； 解锁所有专业版功能。 删除软件内所有广告。 关于只将手机电池最多充到80%，能将电池寿命延长到200%： 相信好多人对于只充电到80%就能提高电池寿命的说法存在异议！那么 AccuBattery 宣称只将手机电池最多充至80%能将电池寿命延长到200%是否有科学依据呢？ 众所周知，现在的手机、平板设备都是用的三元锂电池，而三元锂电池浅充、浅放能使循环寿命长是经过大量试验验证过的。通常三元锂电池单体充放电循环次数大约是500次，这里的循环次数是按100%-0%的容量进行的。大量的试验证明假设您每次只使用50%的电量，那么循环次数会大大提升。 另外循环寿命还受到充电的电压的影响，例如充电电压为2V时的循环寿命比4V有了明显的提升，如果进一步降低充满电压到1V，循环寿命又会进一步提升。而且目前大部分锂电池电动汽车日常充电程序都有相关的设置，例如特斯拉就将日常充电容量设为80%。 所以综上所述只将手机电池最多充到80%相比充到100%一定能延长电池的循环寿命，具体能不能达到延长到200%的效果，还受到您的放电、充电电压等因素的影响。 下载地址 链接：https://pan.baidu.com/s/1T9twwSZXEVH_IwYzq2j_MA 提取码：rrhc","categories":[{"name":"软件推荐","slug":"软件推荐","permalink":"http://norhub.com.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"name":"安卓","slug":"软件推荐/安卓","permalink":"http://norhub.com.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E5%AE%89%E5%8D%93/"}],"tags":[{"name":"破解","slug":"破解","permalink":"http://norhub.com.cn/tags/%E7%A0%B4%E8%A7%A3/"}]},{"title":"如何使用Ubuntu18安装Hive","slug":"如何使用Ubuntu18安装Hive","date":"2020-07-08T09:26:29.000Z","updated":"2021-06-03T03:28:47.000Z","comments":true,"path":"2020/07/08/如何使用Ubuntu18安装Hive/","link":"","permalink":"http://norhub.com.cn/2020/07/08/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Ubuntu18%E5%AE%89%E8%A3%85Hive/","excerpt":"hive是基于hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表并提供类sql查询功能","text":"hive是基于hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表并提供类sql查询功能 准备工作 安装Hive之前必须配置好hadoop环境 安装Hive之前必须配置好JDK 安装好mysql数据库 Hive可以只安装在namenode所在的机器上，如果NameNode有多个，则每个都需要安装，可以不在datanode上安装 为什么要用Hive 直接使用hadoop所面临的问题: 人员学习成本太高 项目周期要求太短 MapReduce实现复杂查询逻辑开发难度太大 为什么要使用Hive 操作接口采用类SQL语法，提供快速开发的能力。 避免了去写MapReduce，减少开发人员的学习成本。 扩展功能很方便。 Hive的特点：可扩展，延展性，容错 Hive的数据存储 Hive中所有的数据都存储在 HDFS 中，没有专门的数据存储格式（可支持Text，SequenceFile，ParquetFile，RCFILE等） 只需要在创建表的时候告诉 Hive 数据中的列分隔符和行分隔符，Hive 就可以解析数据。 Hive 中包含以下数据模型：DB、Table，External Table，Partition，Bucket。 db：在hdfs中表现为${hive.metastore.warehouse.dir}目录下一个文件夹 table：在hdfs中表现所属db目录下一个文件夹 external table：与table类似，不过其数据存放位置可以在任意指定路径 partition：在hdfs中表现为table目录下的子目录 bucket：在hdfs中表现为同一个表目录下根据hash散列之后的多个文件 hive安装 解压： tar -zxvf apache-hive-2.3.7-bin.tar.gz 把解压后的文件移到目录/usr/local/下: mv apache-hive-2.3.7-bin /usr/local/hive 配置hive环境变量 vim /etc/profile 输入下面内容 export HIVE_HOME=/usr/local/hiveexport HIVE_CONF_DIR=$HIVE_HOME/confexport PATH=$PATH:$HIVE_HOME/bin 授权 sudo chown -R hadoop:hadoop /usr/local/hive 使配置文件的修改生效 source /etc/profile 配置hive 配置hive-site.xml 进入目录 cd $HIVE_CONF_DIR 拷贝hive-default.xml.template并重命名为hive-site.xml cp hive-default.xml.template hive-site.xml 编辑hive-site.xml vim hive-site.xml 使用hadoop新建hdfs目录 因为在hive-site.xml中有这样的配置 &lt;name&gt;hive.metastore.warehouse.dir&lt;/name&gt; &lt;value&gt;/user/hive/warehouse&lt;/value&gt; &lt;name&gt;hive.exec.scratchdir&lt;/name&gt; &lt;value&gt;/tmp/hive&lt;/value&gt; 所以要在Hadoop集群新建/user/hive/warehouse目录，执行命令 # 进入Hadoop主目录cd $HADOOP_HOME# 创建目录hadoop fs -mkdir -p /user/hive/warehouse# 新建的目录赋予读写权限hadoop fs -chmod -R 777 /user/hive/warehouse# 新建/tmp/hive/目录hadoop fs -mkdir -p /tmp/hive/# 目录赋予读写权限hadoop fs -chmod -R 777 /tmp/hive# 用以下命令检查目录是否创建成功hadoop fs -ls /user/hivehadoop fs -ls /tmp/hive 修改hive-site.xml中的临时目录 将hive-site.xml文件中的$&#123;system:java.io.tmpdir&#125;替换为hive的临时目录，例如我替换为/usr/local/hive/tmp，该目录如果不存在则要自己手工创建，并且赋予读写权限。 cd $HIVE_HOMEmkdir tmpchmod -R 777 tmp/ 编辑hive-site vim hive-site.xml 在vim中使用下面的代码替换$&#123;system:java.io.tmpdir&#125; :%s#$&#123;system:java.io.tmpdir&#125;#/usr/local/hive/tmp#g 再将配置文件中$&#123;system:user.name&#125;全部替换为root :%s#$&#123;system:user.name&#125;#root#g 例如原来： &lt;property&gt; &lt;name&gt;hive.downloaded.resources.dir&lt;/name&gt;&lt;value&gt;$&#123;system:java.io.tmpdir&#125;/$&#123;hive.session.id&#125;_resources&lt;/value&gt; &lt;description&gt;Temporary local directory for added resources in the remote file system.&lt;/description&gt; &lt;/property&gt; 替换为： &lt;property&gt; &lt;name&gt;hive.downloaded.resources.dir&lt;/name&gt; &lt;!--value&gt;$&#123;system:java.io.tmpdir&#125;/$&#123;hive.session.id&#125;_resources&lt;/value--&gt; &lt;value&gt;/user/local/apache-hive-2.1.1/tmp/$&#123;hive.session.id&#125;_resources&lt;/value&gt; &lt;description&gt;Temporary local directory for added resources in the remote file system.&lt;/description&gt; &lt;/property&gt; 修改hive-site.xml数据库相关的配置 javax.jdo.option.ConnectionDriverName，将该name对应的value修改为MySQL驱动类路径： &lt;property&gt;&lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;&lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;&lt;/property&gt; javax.jdo.option.ConnectionURL，将该name对应的value修改为MySQL的地址： &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;&lt;value&gt;jdbc:mysql://127.0.0.1:3306/hive?createDatabaseIfNotExist=true&amp;amp;useSSL=false&lt;/value&gt; javax.jdo.option.ConnectionUserName，将对应的value修改为MySQL数据库登录名： &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;&lt;value&gt;hive&lt;/value&gt; javax.jdo.option.ConnectionPassword，将对应的value修改为MySQL数据库的登录密码： &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;&lt;value&gt;hive&lt;/value&gt; 将MySQL驱动包上载到Hive的lib目录下 cp /home/heyj/down/mysql-connector-java-5.1.36.jar $HIVE_HOME/lib/ 新建hive-env.sh文件并进行修改 cd $HIVE_CONF_DIR#基于模板创建hive-env.shcp hive-env.sh.template hive-env.shvim hive-env.sh 编辑配置文件并加入以下配置： # Set HADOOP_HOME to point to a specific hadoop install directoryHADOOP_HOME=/usr/local/hadoop# Hive Configuration Directory can be controlled by:export HIVE_CONF_DIR=/usr/local/hive/conf# Folder containing extra libraries required for hive compilation/execution can be controlled by:export HIVE_AUX_JARS_PATH=/usr/local/hive/lib 创建元数据库 登录mysql数据库 mysql -u root -p mysql创建hive用户密码 mysql&gt; CREATE DATABASE hive;mysql&gt; USE hive;mysql&gt; CREATE USER &#x27;hive&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;hive&#x27;;mysql&gt; GRANT ALL ON hive.* TO &#x27;hive&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;hive&#x27;;mysql&gt; GRANT ALL ON hive.* TO &#x27;hive&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;hive&#x27;;mysql&gt; FLUSH PRIVILEGES;mysql&gt; quit; 从Hive 2.1开始，我们需要运行下面的schematool命令作为初始化步骤,MySQL数据库初始化 # 进入到hive的bin目录cd $HIVE_HOME/bin# 对数据库进行初始化schematool -initSchema -dbType mysql 执行成功后，在mysql的hive数据库里已生成metadata数据表： 启动Hive 执行hive的sql命令，在sql位置输入sql命令 hive -e &#x27;sql&#x27; 或者启动hive，在命令行输入sql hive 显示hive中所有的内置函数，测试hive是否可用 hive&gt; show functions; 不报错就安装成功了 启动hiveserver2 启动为前台 hiveserver2 或者使用下面的命令启动 hive --service hiveserver2 启动为后台 nohup hiveserver2 1&gt;/var/log/hiveserver.log 2&gt;/var/log/hiveserver.err &amp; 停止服务 ps -aux | grep hiveserver2 | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; # 获取进程idkill -9 [进程id] # 强制停止 启动成功后，可以在别的节点上用beeline去连接,有两种方法： beeline 回车，进入beeline的命令界面 输入命令连接hiveserver2 beeline&gt; !connect jdbc:hive2://localhost:10000 （hadoop01是hiveserver2所启动的那台主机名，端口默认是10000） 或者启动就连接： beeline -u jdbc:hive2://localhost:10000 -n hadoop 如果hiveserver2无法连接，修改hive.server2.authentication &lt;name&gt;hive.server2.authentication&lt;/name&gt; &lt;value&gt;NOSASL&lt;/value&gt; 在hadoop的core-site.xml中追加 &lt;property&gt; &lt;name&gt;hadoop.proxyuser.root.hosts&lt;/name&gt; &lt;value&gt;*&lt;/value&gt; &lt;/property&gt;&lt;property&gt; &lt;name&gt;hadoop.proxyuser.root.groups&lt;/name&gt; &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hadoop.proxyuser.hadoop.hosts&lt;/name&gt; &lt;value&gt;*&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hadoop.proxyuser.hadoop.groups&lt;/name&gt; &lt;value&gt;*&lt;/value&gt;&lt;/property&gt; 浏览器打开ip(安装hive的主机ip地址)+端口10002，就能看到hiveserver2服务web页面 hive常用命令 显示命令 show tables; -- 显示表 show databases; -- 显示数据库 show partitions t_4; -- 显示表分区 show functions; -- 显示hive中所有的内置函数 desc t_name; -- 显示表定义 desc extended t_name; -- 显示表定义的详细信息 desc formatted table_name; -- 显示表定义的详细信息，并且用比较规范的格式显示 show create table table_name; -- 显示建表语句 可以查看表创建语句 创建表 create database hive_db -- 创建数据库 use hive_db -- 使用数据库 create table if not exists table_name (foo int, bar string) row format delimited fields terminated by ',' stored as textfile; -- 创建内部表 create external table if not exists pageview(pageid int,page_url string comment 'The page URL') row format delimited fields terminated by ',' location 'hdfs://mini1:9000/user/hive/warehouse/' -- 创建外部表 create table student_p(Sno int,Sname string,Sex string,Sage int,Sdept string) partition by(part string) row format delimited fields terminated by ',' stored as textfile; -- 创建分区表 create table student(id int,age int,name string) partitioned by(stat_date string) clustered by(id) sorted by (age) into 2 buckets row format delimited fields terminated by ','; -- 创建分桶表 修改表 alter table student_p add partition(part='a') partition(part='b'); -- 增加分区 alter table table_name rename to new_table_name; -- 重命名表 删除表 drop table table_name; -- 删除表 truncate table table_name; -- 删除表中的数据 alter table table_name drop partition (partition_name='分区名') -- 按分区删除数据 增加数据 load data local inpath '/home/hadoop/data/data.txt' into table table_name; -- 本地模式加载数据到表","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Linux","slug":"程序开发/Linux","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://norhub.com.cn/tags/ubuntu/"},{"name":"hdfs","slug":"hdfs","permalink":"http://norhub.com.cn/tags/hdfs/"},{"name":"hive","slug":"hive","permalink":"http://norhub.com.cn/tags/hive/"}]},{"title":"如何使用Docker部署Flask应用","slug":"如何使用Docker部署Flask应用","date":"2020-07-08T01:58:09.000Z","updated":"2021-05-21T05:32:43.000Z","comments":true,"path":"2020/07/08/如何使用Docker部署Flask应用/","link":"","permalink":"http://norhub.com.cn/2020/07/08/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2Flask%E5%BA%94%E7%94%A8/","excerpt":"Docker部署Flask应用","text":"Docker部署Flask应用 创建应用 创建一个文件夹testflask mkdir testflask 创建一个Flask应用 testflask/app.py，这是项目的启动文件 from flask import Flaskapp = Flask(__name__)@app.route(&#x27;/&#x27;)def hello_world(): return &#x27;Hello World!&#x27;if __name__ == &#x27;__main__&#x27;: app.run() 使用Gunicorn+Gevent运行Flask应用 Flask应用是一个符合WSGI规范的Python应用，不能独立运行（类似app.run的方式仅适合开发模式），需要依赖其他的组件提供服务器功能。在这里，我们选择Gunicorn+Gevent的组合。 在根目录下新建Gunicorn配置文件 testflask/gunicorn.conf.py workers = 5 # 定义同时开启的处理请求的进程数量，根据网站流量适当调整worker_class = &quot;gevent&quot; # 采用gevent库，支持异步处理请求，提高吞吐量bind = &quot;0.0.0.0:8888&quot; # 监听IP放宽，以便于Docker之间、Docker和宿主机之间的通信 在本地测试是否能正确运行 pip install flask gunicorn geventgunicorn start:app -c gunicorn.conf.py Docker运行Flask应用 首先我们需要为该应用创建一个testflask/requirements.txt文件，以便容器里面python环境的安装 gunicorngeventflask 在安装 python 应用依赖的三方包时，可以直接用如下命令执行 pip install -r requirements.txt 然后我们还要创建一个 testflask/Dockerfile 文件，以便Docker镜像的构建 FROM python:3.6WORKDIR /usr/src/appCOPY requirements.txt ./RUN pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simpleCOPY . .CMD [&quot;gunicorn&quot;, &quot;app:app&quot;, &quot;-c&quot;, &quot;./gunicorn.conf.py&quot;] 其中，第一行是python版本，第二行 WORKDIR 后面写的是要部署到服务器上的路径，最后一行里面的 app 是我们上面写的 python 启动文件名，第二个app 是启动文件里面要启动的应用名（变量名） 完成这两个文件的创建之后，执行如下命令，就可以开始构建Docker镜像 sudo docker build -t &#x27;testflask&#x27; . 这个过程需要一点时间，因为它有几百兆。 构建完成之后，通过如下命令查看镜像列表，可以发现 testflask 显示在其中 sudo docker images 临时运行docker镜像 sudo docker run -it --rm -p 8888:8888 testflask 可以看到Docker镜像成功地运行起来了，并处于阻塞状态。这时，我们打开浏览器，输入127.0.0.1:8888，可以看到返回的网页中展示内容Hello World! 生产环境运行(以daemon方式运行) sudo docker run -d -p 8888:8888 --name test-flask-1 testflask","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"程序开发/Python","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Python/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://norhub.com.cn/tags/docker/"},{"name":"python","slug":"python","permalink":"http://norhub.com.cn/tags/python/"},{"name":"flask","slug":"flask","permalink":"http://norhub.com.cn/tags/flask/"}]},{"title":"[转]Docker部署Zabbix+Grafana","slug":"转-Docker部署Zabbix-Grafana","date":"2020-05-23T04:13:43.000Z","updated":"2021-06-03T03:38:50.000Z","comments":true,"path":"2020/05/23/转-Docker部署Zabbix-Grafana/","link":"","permalink":"http://norhub.com.cn/2020/05/23/%E8%BD%AC-Docker%E9%83%A8%E7%BD%B2Zabbix-Grafana/","excerpt":"","text":"permalink: https://2heng.xin/2019/09/10/docker-zabbix-grafana/","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Docker","slug":"程序开发/Docker","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://norhub.com.cn/tags/docker/"}],"author":{"name":"Mashiro","avatar":"https://gravatar.2heng.xin/avatar/cd2b3a164c977539712929f66cad335c?s=96&d=mm&r=g","url":"https://2heng.xin/"}},{"title":"Docker的常用命令介绍","slug":"Docker的常用命令介绍","date":"2020-05-09T12:09:22.000Z","updated":"2021-05-21T05:26:11.000Z","comments":true,"path":"2020/05/09/Docker的常用命令介绍/","link":"","permalink":"http://norhub.com.cn/2020/05/09/Docker%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/","excerpt":"Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。","text":"Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 sudo service docker start # 启动dockersudo service docker stop # 停止dockersudo service docker restart # 重启dockersudo systemctl enable docker # 开机启动docker# 列出镜像docker image ls# 拉取镜像docker image pull library/hello-world# 删除镜像docker image rm 镜像id/镜像ID# 创建容器docker run [选项参数] 镜像名 [命令]# 停止一个已经在运行的容器docker container stop 容器名或容器id# 启动一个已经停止的容器docker container start 容器名或容器id# kill掉一个已经在运行的容器docker container kill 容器名或容器id# 删除容器docker container rm 容器名或容器id 启动容器 docker start &lt;容器id或name&gt; 使容器自启动 docker update --restart=always &lt;容器id或name&gt; --restart具体参数值详细信息： no - 容器退出时，不重启容器； on-failure - 只有在非0状态退出时才从新启动容器； always - 无论退出状态是如何，都重启容器；","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Docker","slug":"程序开发/Docker","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://norhub.com.cn/tags/docker/"}]},{"title":"使用Ubuntu19.10搭建一个编程工作站如何配置","slug":"使用Ubuntu19.10搭建一个编程工作站如何配置","date":"2020-04-16T03:31:30.000Z","updated":"2021-06-03T03:31:43.000Z","comments":true,"path":"2020/04/16/使用Ubuntu19.10搭建一个编程工作站如何配置/","link":"","permalink":"http://norhub.com.cn/2020/04/16/%E4%BD%BF%E7%94%A8Ubuntu19.10%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BC%96%E7%A8%8B%E5%B7%A5%E4%BD%9C%E7%AB%99%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE/","excerpt":"ubuntu在个人工作站与服务器领域都表现的非常稳定优秀，工程师使用ubuntu做为个人开发电脑完全没有问题，功能齐全性能稳定，因为用户众多解决问题也比较容易。","text":"ubuntu在个人工作站与服务器领域都表现的非常稳定优秀，工程师使用ubuntu做为个人开发电脑完全没有问题，功能齐全性能稳定，因为用户众多解决问题也比较容易。 下载 从官网下载https://ubuntu.com/download/desktop 制作u盘启动盘 点击链接 选择第二步，下载工具 点击下载 双击打开刚才下载的工具，选择镜像后点开始制作 安装系统 重启电脑按f12选择u盘启动，根据自己主板可能其他按键 如果要装双系统可以选择其他选项 等待安装完成 设置镜像源 打开软件和更新 选择下载服务器为阿里云 等待完成 更新系统 打开软件更新器，更新系统 执行系统更新 重启 使用终端 打开终端 安装常用软件vim,git,php 设置桌面 在软件里面找到tweaks工具，用来设置ubuntu桌面 进入安装页面选择安装 打开刚才下载的工具，设置不显示桌面图标 设置顶栏显示时间和电池百分比 在桌面右击打开显示设置 选择一个桌面背景 单击设置为桌面背景 设置dock栏显示在底部和自动隐藏 设置主题 访问 https://www.pling.com/p/1136805/ ,安装主题工具 选择打开 等待完成出现安装 安装完成 访问https://vinceliuice.github.io/ ，选择一个主题 我选择mac主题 用终端下载安装图标 使用tweaks工具设置主题和图标 安装vscode 安装vscode,选择下载deb 安装 打开vscode商店，安装sync同步工具，点击Download Public Gist输入86120a7addb2aa40b20514be7d130991开始同步 安装字体 下载字体 打开安装","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Linux","slug":"程序开发/Linux","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://norhub.com.cn/tags/ubuntu/"}]},{"title":"Hexo博客快速搭建","slug":"Hexo博客快速搭建","date":"2020-04-15T06:19:06.000Z","updated":"2021-06-03T03:33:04.000Z","comments":true,"path":"2020/04/15/Hexo博客快速搭建/","link":"","permalink":"http://norhub.com.cn/2020/04/15/Hexo%E5%8D%9A%E5%AE%A2%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA/","excerpt":"新建仓库 github 新建一个仓库，仓库名必须为 .github.io 格式，其中 是你 github 的昵称 全局安装hexo npm install hexo-cli -g 初始化项目 hexo init，就会自动构建一个 hexo 项目，紧接着执行 hexo s，浏览器访问 localhost:4000 就可以看到效果啦","text":"新建仓库 github 新建一个仓库，仓库名必须为 .github.io 格式，其中 是你 github 的昵称 全局安装hexo npm install hexo-cli -g 初始化项目 hexo init，就会自动构建一个 hexo 项目，紧接着执行 hexo s，浏览器访问 localhost:4000 就可以看到效果啦 部署到github 在项目根目录下找到 _congif.yml，找到 deploy 字段并填写完整 deploy: type: git repo: &lt;你的仓库地址&gt; # https://github.com/YouName/YouName.github.io branch: master 我们需要额外的一个工具来帮助我们推到仓库上，那就是 hexo-deployer-git npm install hexo-deployer-git --save 执行下面两个命令，就可以把项目自动部署到 github hexo cleanhexo deploy 浏览器访问：https://YouName.github.io/ 即可看到效果。 创建新文章 // [layout] 为布局，可选项为 `post`、`page`、`draft`，这将决定文章所在文件路径。// &lt;title&gt; 为文章标题hexo new [layout] &lt;title&gt; 常用Hexo命令 初始化目录：hexo init [folder] 新建文章：hexo new [layout] &lt;title&gt;或hexo n [layout] &lt;title&gt; 新建草稿：hexo new draft &lt;title&gt; 将草稿发布为正式文章：hexo publish &lt;title&gt; 生成静态文件：hexo generate或hexo g 监听文件变化：hexo g --watch或hexo g -w 部署：hexo deploy或hexo d 先生成后部署：hexo d -g 启动本地服务器（服务器会监听文件变化并自动更新）：hexo server或hexo s 启动调试：hexo s --debug 预览草稿：hexo s --draft 清除缓存：hexo clean 重新部署 在更换电脑后，要把博客文件夹移动到新电脑,执行两个命令 安装hexo npm install hexo-cli -g 安装模块，不要用hexo init初始化，部分文件已经拷贝生成，如果不慎使用，则站点配置文件_config.yml会被初始化为默认值 npm install --registry=https://registry.npm.taobao.org","categories":[{"name":"其他","slug":"其他","permalink":"http://norhub.com.cn/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://norhub.com.cn/tags/hexo/"}]},{"title":"Oracle导入导出工具的使用","slug":"Oracle导入导出工具的使用","date":"2020-04-15T06:07:07.000Z","updated":"2021-06-03T03:32:35.000Z","comments":true,"path":"2020/04/15/Oracle导入导出工具的使用/","link":"","permalink":"http://norhub.com.cn/2020/04/15/Oracle%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"迁移Oracle数据库需要用到导入导出工具exp和imp,可直接跨平台系统导入导出数据,速度较慢，操作简单","text":"迁移Oracle数据库需要用到导入导出工具exp和imp,可直接跨平台系统导入导出数据,速度较慢，操作简单 导用户 导出用户MDM_P到当前文件夹（导出文件为testDb.dmp） exp MDM_P/8888@192.168.134.9:1521/ora11g file='./testDb.dmp' owner=MDM_P 从当前文件夹导入MDM_P用户 imp MDM_P/8888@192.168.135.10/orcl file=./testDb.dmp fromuser=MDM_P 导数据库 将数据库ORCL完全导出到D盘（导出文件为testDb.dmp）其中full=y表示全库导出： exp scott/tiger@192.168.1.1:1521/ORCL file='d:/testDb.dmp' full=y 将D:\\example.dmp文件中的库导入到mydb下的system用户中 imp system/123456@213.234.12.32/mydb file=D:\\example.dmp full=y ignore=y 如果表已经存在，则会报错，在后面加上igonre=y（忽略创建错误，继续后面操作）。 导表 将数据库的表table1,table2导到D盘（导出文件为testDb.dmp）： exp scott/tiger@192.168.1.1:1521/ORCL file='d:/testDb.dmp' tables=(table1,table2) exp方式导出数据 相关参数项如下： 关键字 说明 默认 USERID 用户名/口令 FULL 导出整个文件 (N) BUFFER 数据缓冲区的大小 OWNER 导出指定的所有者用户名列表 FILE 输出文件 (EXPDAT.DMP) TABLES 导出指定的表名列表 COMPRESS 是否压缩导出的文件 (Y) RECORDLENGTH IO 记录的长度 GRANTS 导出权限 (Y) INCTYPE 增量导出类型 INDEXES 导出索引 (Y) RECORD 跟踪增量导出 (Y) ROWS 导出数据行 (Y) PARFILE 参数文件名 CONSTRAINTS 导出限制 (Y) CONSISTENT 交叉表一致性 LOG 屏幕输出的日志文件 STATISTICS 分析对象(ESTIMATE) DIRECT 直接路径 (N) TRIGGERS 导出触发器 (Y) FEEDBACK 显示每 x 行 (0) 的进度 FILESIZE 各转储文件的最大尺寸 QUERY 选定导出表子集的子句 TRANSPORT_TABLESPACE 导出可传输的表空间元数据 (N) TABLESPACES 导出指定的表空间列表 imp方式导入数据 相关参数项如下： 关键字 说明 默认 USERID 用户名/口令 FULL 导入整个文件 (N) BUFFER 数据缓冲区大小 FROMUSER 所有人用户名列表 FILE 输入文件 (EXPDAT.DMP) TOUSER 用户名列表 SHOW 只列出文件内容 (N) TABLES 表名列表 IGNORE 忽略创建错误 (N) RECORDLENGTH IO记录的长度 GRANTS 导入权限 (Y) INCTYPE 增量导入类型 INDEXES 导入索引 (Y) COMMIT 提交数组插入 (N) ROWS 导入数据行 (Y) PARFILE 参数文件名 LOG 屏幕输出的日志文件 CONSTRAINTS 导入限制 (Y) DESTROY 覆盖表空间数据文件 (N) INDEXFILE 将表/索引信息写入指定的文件 SKIP_UNUSABLE_INDEXES 跳过不可用索引的维护 (N) FEEDBACK 每 x 行显示进度 TOID_NOVALIDATE 跳过指定类型 ID 的验证 FILESIZE 每个转储文件的最大大小 STATISTICS 始终导入预计算的统计信息 RESUMABLE 在遇到有关空间的错误时挂起 RESUMABLE_NAME 用来标识可恢复语句的文本字符串 RESUMABLE_TIMEOUT RESUMABLE 的等待时间 COMPILE 编译过程, 程序包和函数 (Y) STREAMS_CONFIGURATION 导入 Streams 的一般元数据 (Y) STREAMS_INSTANITATION 导入 Streams 的实例化元数据 (N) TRANSPORT_TABLESPACE 导入可传输的表空间元数据 TABLESPACES 将要传输到数据库的表空间 DATAFILES 将要传输到数据库的数据文件 TTS_OWNERS 拥有可传输表空间集中数据的用户 交互命令方式导入导出 导出工具 exp 它是操作系统下一个可执行的文件 存放目录/ORACLE_HOME/bin exp导出工具将数据库中数据备份压缩成一个二进制系统文件.可以在不同OS间迁移 它有三种模式： a. 用户模式： 导出用户所有对象以及对象中的数据； b. 表模式： 导出用户所有表或者指定的表； c. 整个数据库： 导出数据库中所有对象。 导出工具exp交互式命令行方式的使用的例子 $exp test/test123@appdbEnter array fetch buffer size: 4096 &gt; 回车Export file: expdat.dmp &gt; m.dmp 生成导出的文件名 (1)E(ntire database), (2)U(sers), or (3)T(ables): (2)U &gt; 3Export table data (yes/no): yes &gt; 回车Compress extents (yes/no): yes &gt; 回车Export done in ZHS16GBK character set and ZHS16GBK NCHAR character setAbout to export specified tables via Conventional Path ...Table(T) or Partition(T:P) to be exported: (RETURN to quit) &gt; cmamenu 要导出的表名. . exporting table CMAMENU 4336 rows exportedTable(T) or Partition(T:P) to be exported: (RETURN to quit) &gt;要导出的表名nTable(T) or Partition(T:P) to be exported: (RETURN to quit) &gt; 回车Export terminated successfully without warnings. 导出工具exp非交互式命令行方式的例子 $exp scott/tiger tables=(emp,dept) file=/directory/scott.dmp grants=y # 说明:把scott用户里两个表emp,dept导出到文件/directory/scott.dmp$exp scott/tiger tables=emp query=\\&quot;where job=\\&#x27;salesman\\&#x27; and sal\\&lt;1600\\&quot; file=/directory/scott2.dmp # 说明:在exp里面加上导出emp的查询条件job=&#x27;salesman&#x27; and sal&lt;1600 (但我个人很少这样用,还是把满足条件的记录生成临时表后,再exp会方便一些)$exp parfile=username.par file=/directory1/username_1.dmp,/directory1/username_2.dmp filesize=2000M log=/directory2/username_exp.log 参数文件username.par内容 userid=username/userpasswordbuffer=8192000compress=ngrants=y 说明:username.par为导出工具exp用的参数文件,里面具体参数可以根据需要去修改 filesize指定生成的二进制备份文件的最大字节数 (可用来解决某些OS下2G物理文件的限制及加快压缩速度和方便刻历史数据光盘等) 导入工具 imp 它是操作系统下一个可执行的文件 存放目录/ORACLE_HOME/bin imp导入工具将EXP形成的二进制系统文件导入到数据库中. 它有三种模式： a. 用户模式： 导出用户所有对象以及对象中的数据； b. 表模式： 导出用户所有表或者指定的表； c. 整个数据库： 导出数据库中所有对象。 只有拥有IMP_FULL_DATABASE和DBA权限的用户才能做整个数据库导入 imp步骤： (1) create table (2) insert data (3) create index (4) create triggers,constraints 2.导入工具imp交互式命令行方式的例子 $ impImport: Release 8.1.6.0.0 - Production on 星期五 12月 7 17:01:08 2001(c) Copyright 1999 Oracle Corporation. All rights reserved.用户名: test口令:****连接到: Oracle8i Enterprise Edition Release 8.1.6.0.0 - 64bit ProductionWith the Partitioning optionJServer Release 8.1.6.0.0 - Production导入文件: expdat.dmp&gt; /tmp/m.dmp输入插入缓冲区大小（最小为 8192 ) 30720&gt;经由常规路径导出由EXPORT:V08.01.06创建的文件警告: 此对象由 TEST 导出, 而不是当前用户已经完成ZHS16GBK字符集和ZHS16GBK NCHAR 字符集中的导入只列出导入文件的内容(yes/no)：no&gt;由于对象已存在, 忽略创建错误(yes/no)：no&gt; yes导入权限(yes/no)：yes&gt;导入表数据(yes/no)：yes&gt;导入整个导出文件(yes/no)：no&gt; yes. 正在将TEST的对象导入到 SCOTT. . 正在导入表 &quot;CMAMENU&quot; 4336行被导入成功终止导入，但出现警告。 3.导入工具imp非交互式命令行方式的例子 $ imp system/manager fromuser=jones tables=(accts) $ imp system/manager fromuser=scott tables=(emp,dept) $ imp system/manager fromuser=scott touser=joe tables=emp $ imp scott/tiger file = expdat.dmp full=y $ imp scott/tiger file = /mnt1/t1.dmp show=n buffer=2048000 ignore=n commit=y grants=y full=y log=/oracle_backup/log/imp_scott.log$ imp system/manager parfile=params.dat params.dat 内容 file=dba.dmp show=n ignore=n grants=y fromuser=scott tables=(dept,emp) 4.导入工具imp可能出现的问题 (1) 数据库对象已经存在 一般情况, 导入数据前应该彻底删除目标数据下的表, 序列, 函数/过程,触发器等; 数据库对象已经存在, 按缺省的imp参数, 则会导入失败 如果用了参数ignore=y, 会把exp文件内的数据内容导入 如果表有唯一关键字的约束条件, 不合条件将不被导入 如果表没有唯一关键字的约束条件, 将引起记录重复 (2) 数据库对象有主外键约束 不符合主外键约束时, 数据会导入失败 解决办法: 先导入主表, 再导入依存表 disable目标导入对象的主外键约束, 导入数据后, 再enable它们 (3) 权限不够 如果要把A用户的数据导入B用户下, A用户需要有imp_full_database权限 (4) 导入大表( 大于80M ) 时, 存储分配失败 默认的EXP时, compress = Y, 也就是把所有的数据压缩在一个数据块上. 导入时, 如果不存在连续一个大数据块, 则会导入失败. 导出80M以上的大表时, 记得compress= N, 则不会引起这种错误. (5) imp和exp使用的字符集不同 如果字符集不同, 导入会失败, 可以改变unix环境变量或者NT注册表里NLS_LANG相关信息. 导入完成后再改回来. (6) imp和exp版本不能往上兼容 imp可以成功导入低版本exp生成的文件, 不能导入高版本exp生成的文件 根据情况我们可以用 $ imp username/password@connect_string 说明: connect_string 是在/ORACLE_HOME/network/admin/tnsnames.ora 定义的本地或者远端数据库的名称 注意事项: UNIX: /etc/hosts 要定义本地或者远端数据库服务器的主机名 win98: windows\\hosts 和IP地址的对应关系 win2000: winnt\\system32\\drivers\\etc\\hosts","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"数据库","slug":"程序开发/数据库","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://norhub.com.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"oracle","slug":"oracle","permalink":"http://norhub.com.cn/tags/oracle/"}]},{"title":"在Ubuntu16.04使用命令行方式安Matlab","slug":"在Ubuntu16.04使用命令行方式安Matlab","date":"2020-04-15T06:02:43.000Z","updated":"2021-06-03T03:31:35.000Z","comments":true,"path":"2020/04/15/在Ubuntu16.04使用命令行方式安Matlab/","link":"","permalink":"http://norhub.com.cn/2020/04/15/%E5%9C%A8Ubuntu16.04%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%96%B9%E5%BC%8F%E5%AE%89Matlab/","excerpt":"Linux服务器命令行模式安装Matlab","text":"Linux服务器命令行模式安装Matlab 安装jdk java -version #查看当前java版本，未出现版本信息代表未安装sudo apt-get install default-jdk #使用apt-get安装JDKjava -version #再次查询Java版本，查看是否安装成功 安装matlab 创建挂载文件夹，挂载镜像 sudo mkdir /data/matlabsudo mount -o loop R2018b_glnxa64_dvd1.iso /data/matlab 创建安装目录 sudo mkdir -p /data/MATLAB/etcsudo mkdir -p /data/MATLAB/R2018b 拷贝配置文件 sudo cp /data/matlab/installer_input.txt /data/MATLAB/etcsudo cp /data/matlab/activate.ini /data/MATLAB/etcsudo cp license_standalone.lic /data/MATLAB/etc 修改文件的读写属性 chmod +w /data/MATLAB/etc/installer_input.txtchmod +w /data/MATLAB/etc/activate.ini 编辑activate.ini文件，按如下内容设置 isSilent=true #开启silent模式activateCommand=activateOffline #设置激活方式, 离线激活 无需联网licenseFile=/usr/local/MATLAB/etc/license_standalone.lic #license文件位置 sudo /data/matla/install -mode silent -agreeToLicense yes -fileInstallationKey 09806-07443-53955-64350-21751-41297 -destinationFolder /data/MATLAB/R2018b -activationPropertiesFile /data/MATLAB/etc/activate.ini -licensePath /data/MATLAB/etc/license_standalone.lic -outputFile /tmp/mathwork_install.log 分别指定：开启无人值守安装，同意协议，序列号，安装目录，激活文件，license文件 激活文件内容： isSilent=true #开启silent模式activateCommand=activateOffline #设置激活方式, 离线激活 无需联网licenseFile=/usr/local/MATLAB/etc/license_standalone.lic #license文件位置 此时不要CTRL+C中止，而是另开一个命令行窗口,将挂载的dvd1.iso推出，然后在原目录下挂载dvd2.iso即可 sudo umount /media/cdromsudo mount -o loop R2018b_glnxa64_dvd2.iso /data/matlab 出现End - Successful就安装成功 破解matlab 替换so文件 cp ./Crack/R2018b/bin/glnxa64/matlab_startup_plugins/lmgrimpl/* /data/MATLAB/R2018b/bin/glnxa64/matlab_startup_plugins/lmgrimpl 破解 sudo /data/MATLAB/R2018b/bin/activate_matlab.sh -isSilent -propertiesFile /data/MATLAB/etc/activate.ini 配置环境变量 vim ~/.bashrcexport MATLAB_HOME=/home/zh/MATLAB/2018bexport PATH=$&#123;MATLAB_HOME&#125;/bin:$PATH 保存退出后激活 source ~/.bashrc","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Linux","slug":"程序开发/Linux","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Linux/"},{"name":"Matlab","slug":"程序开发/Matlab","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Matlab/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://norhub.com.cn/tags/ubuntu/"},{"name":"matlab","slug":"matlab","permalink":"http://norhub.com.cn/tags/matlab/"}]},{"title":"如何使用Ubuntu部署Flask+gunicorn","slug":"如何使用Ubuntu部署Flask+gunicorn","date":"2020-04-15T05:56:15.000Z","updated":"2021-06-03T01:15:50.000Z","comments":true,"path":"2020/04/15/如何使用Ubuntu部署Flask+gunicorn/","link":"","permalink":"http://norhub.com.cn/2020/04/15/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Ubuntu%E9%83%A8%E7%BD%B2Flask+gunicorn/","excerpt":"Gunicorn是一个unix上被广泛使用的高性能的Python WSGI UNIX HTTP Server。 和大多数的web框架兼容，并具有实现简单，轻量级，高性能等特点。","text":"Gunicorn是一个unix上被广泛使用的高性能的Python WSGI UNIX HTTP Server。 和大多数的web框架兼容，并具有实现简单，轻量级，高性能等特点。 安装gunicorn 安装pip版本 pip3 install gunicorn 或者安装ubuntu版本 sudo apt-get install gunicorn flask示例 from flask import Flaskapp = Flask(__name__)@app.route(&#x27;/demo&#x27;, methods=[&#x27;GET&#x27;])def demo(): return &quot;gunicorn and flask demo.&quot; gunicorn运行flask app # 普通模式启动gunicorn -w 4 -b 127.0.0.1:5001 manage:app# 后台模式启动gunicorn -w 4 -D -b 127.0.0.1:5001 manage:app# 配置文件模式启动gunicorn --preload -c gunicorn.conf.py manage:app# 停止运行killall -9 gunicorn 配置supervisor 在production环境，起停和状态的监控最好用supervisior之类的监控工具，然后在gunicorn的前端放置一个http proxy server, 譬如nginx。 用apt安装supervisor sudo apt-get install supervisor 生成默认配置文件 echo_supervisord_config &gt; /etc/supervisor/supervisord.conf 加入监控程序的配置 [program:gunicorn_demo]directory=/var/www/gunicorn_demo/command=gunicorn --preload -c gunicorn_demo.py gunicorn_demo:app ; 程序启动命令autostart=true ; 在supervisord启动的时候也自动启动startsecs=10 ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒autorestart=true ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启startretries=3 ; 启动失败自动重试次数，默认是3user=root ; 用哪个用户启动进程，默认是rootpriority=999 ; 进程启动优先级，默认999，值小的优先启动redirect_stderr=true ; 把stderr重定向到stdout，默认falsestdout_logfile_maxbytes=100MB ; stdout 日志文件大小，默认50MBstdout_logfile_backups = 20 ; stdout 日志文件备份数，默认是10; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）stdout_logfile=/var/log/supervisor_logs/axf.outstopasgroup=false ;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程killasgroup=false ;默认为false，向进程组发送kill信号，包括子进程 supervisor常用命令 sudo supervisorctl status //查看所有进程的状态sudo supervisorctl stop es //停止essudo supervisorctl start es //启动essudo supervisorctl restart es //重启essudo supervisorctl update //配置文件修改后使用该命令加载新的配置sudo supervisorctl reload //重新启动配置中的所有程序 把es换成all可以管理配置中的所有进程。直接输入supervisorctl进入supervisorctl的shell交互界面，此时上面的命令不带supervisorctl可直接使用。 如果启动问题,先去看看log log的位置 stdout_logfile=/var/log/supervisor_logs/axf.out 配置nginx 为什么有了gunicorn为什么还需要nginx？因为nginx具备优秀的静态内容处理能力，然后将动态内容转发给gunicorn服务器，这样可以达到很好的客户端响应。 安装nginx sudo apt-get install nginx mynginx.conf是需要自己创建的一个nginx配置文件，此文件放在项目文件夹中，配置内容如下 server &#123; listen 9001; server_name 203.176.71.157 localhost; # 这是HOST机器的外部域名，用地址也行 access_log /var/www/iclinicAI/logs/access.log; error_log /var/www/iclinicAI/logs/error.log; client_max_body_size 100M; location / &#123; proxy_pass http://127.0.0.1:5001; # 这里是指向 gunicorn host 的服务地址 proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_read_timeout 60; &#125; &#125; 刚建立的配置文件使用符号链接到Nginx配置文件文件夹中 sudo ln -s /var/www/iclinicAI/mynginx.conf /etc/nginx/conf.d/sudo /etc/init.d/nginx restart # 重启nginx gunicorn配置 # gunicorn.conf.py# 监听地址和端口。bind = &quot;127.0.0.1:5001&quot;# worker进程的数量。建议值2-4 x $(NUM_CORES)， 缺省为1。workers = 2# worker进程的工作方式。 有 sync, eventlet, gevent, tornado, gthread, 缺省值sync。# 这里工作模式协程worker_class = &#x27;gevent&#x27;# 工作进程中线程的数量。建议值2-4 x $(NUM_CORES)， 缺省值1。# 此配置只适用于gthread 进程工作方式， 因为gevent这种使用的是协程工作方式。# threads = 2# worker重启之前处理的最大requests数， 缺省值为0表示自动重启disabled。主要是防止内存泄露。max_requests = 50000# 抖动参数，防止worker全部同时重启。max_requests_jitter = 2timeout = 70graceful_timeout = 30limit_request_line = 8190limit_request_fields = 200limit_request_fields_size = 8190# 设置最大并发量worker_connections = 2000# 设置gunicorn访问日志格式，错误日志无法设置access_log_format = &#x27;%(t)s %(p)s %(h)s &quot;%(r)s&quot; %(s)s %(L)s %(b)s %(f)s&quot; &quot;%(a)s&quot;&#x27;# 设置进程文件目录pidfile = &#x27;/var/www/IASDataFlask/run/gunicorn.pid&#x27;# 设置访问日志和错误信息日志路径accesslog = &#x27;/var/www/IASDataFlask/logs/gunicorn_acess.log&#x27;errorlog = &#x27;/var/www/IASDataFlask/logs/gunicorn_error.log&#x27;# 设置日志记录水平loglevel = &#x27;warning&#x27; 其他说明 gunicorn 命令参数详解 --version # 显示程序的版本号并退出-h, --help # 显示此帮助消息并退出-c FILE, --config=FILE # Gunicorn配置文件的路径。 [None]--debug # 在服务器中打开调试。 [False]--spew # 安装一个跟踪函数，该函数将抛出服务器执行的每一行。 [False]--access-logfile=FILE # 要写入的访问日志文件。 [None]--access-logformat=STRING # 访问日志格式。 [%(h)s %(l)s %(u)s %(t)s &quot;%(r)s&quot; %(s)s %(b)s &quot;%(f)s&quot; &quot;%(a)s&quot;]--error-logfile=FILE, --log-file=FILE # 要写入的错误日志文件。 [-]--log-level=LEVEL # 错误日志输出的等级。 [info]--logger-class=STRING # 要用在gunicorn中记录事件的日志记录器。 [simple]-n STRING, --name=STRING # 与setproctitle一起用于进程命名的基础。 [None]--preload # 在worker进程被复制（派生）之前载入应用的代码。通过预加载应用，可以节省内存资源和提高服务启动时间。当然，如果你将应用加载进worker进程这个动作延后，那么重启worker将会容易很多。--reload # 更改代码的时候重启workers， 只建议在开发过程中开启。文档推荐下载inotify这个包来作为重载引擎。--reload_engine # 选择重载的引擎，支持的有三种，分别是auto，poll，inotify（需要单独安装） -D, --daemon # 以守护进程形式来运行Gunicorn进程。其实就是将这个服务放到后台去运行。 [False]-p FILE, --pid=FILE # PID文件使用的文件名。 [None]-u USER, --user=USER # 将工作进程切换为以该用户身份运行。[1000]-g GROUP, --group=GROUP # 切换工作进程以该组身份运行。 [1000]-m INT, --umask=INT # Gunicorn编写的文件上文件模式的位掩码。 [0]-b ADDRESS, --bind=ADDRESS # 要绑定的套接字。 [127.0.0.1:8000]--backlog=INT # 最大挂起连接数。 [2048]-w INT, --workers=INT # 处理请求的工作进程数。 [1]-k STRING, --worker-class=STRING # 使用的工作类型。 [sync]--worker-connections=INT # 并发客户端的最大数量。 [1000]--max-requests=INT # 工作进程在重新启动之前将处理的最大请求数。 [0]-t INT, --timeout=INT # 超过这个时间的工作进程被杀死并重新启动。 [30]--keep-alive=INT # 等待“保持活动”连接上的请求的秒数。 [2] gunicorn 配置文件详解 gunicorn 配置项可以通过 gunicorn 的启动命令行中设定，也可以通过配置文件指定。强烈建议使用一个配置文件。 配置项如下： server socket bind 监听地址和端口。 backlog 服务器中在 pending 状态的最大连接数，即 client 处于 waiting 的数目。超过这个数目， client 连接会得到一个 error。 建议值 64-2048。 worker 进程 workers worker 进程的数量。建议值 2-4 x $(NUM_CORES)， 缺省为 1。 worker_class worker 进程的工作方式。 有 sync, eventlet, gevent, tornado, gthread, 缺省值 sync。 threads 工作进程中线程的数量。建议值 2-4 x $(NUM_CORES)， 缺省值 1。 此配置只适用于 gthread 进程工作方式， 因为 gevent 这种使用的是协程工作方式。 worker_connections 客户端最大同时连接数。只适用于 eventlet， gevent 工作方式。 max_requests worker 重启之前处理的最大 requests 数， 缺省值为 0 表示自动重启 disabled。主要是防止内存泄露。 max_requests_jitter 抖动参数，防止 worker 全部同时重启。 timeout 通常设为 30。 graceful_timeout 接收到 restart 信号后，worker 可以在 graceful_timeout 时间内，继续处理完当前 requests。 keepalive server 端保持连接时间。 security limit_request_line http request line 最大字节数。值范围 0-8190， 0 表示无限制。 limit_request_field http request 中 header 字段数的最大值。缺省为 100，最大 32768。 limit_request_field_size http request header 字段最大字节数。0 表示无限制。 调试 reload 当代码有修改时，自动重启 workers。适用于开发环境。 reload_extra_files 扩展 reload 配置，增加 templates，configurations 等文件修改监控。 spew 跟踪程序执行的每一行。 check_config 检查配置。 server 机制 sendfile 系统底层拷贝数据方式，提供 performance。 chdir 在 app 加载之前，进入到此目录。 daemon 应用是否以 daemon 方式运行。 raw_env key=value, 传递环境参数。 pidfile pid 存储文件路径。 worker_tmp_dir 临时工作目录。 user 指定 worker 进程的运行用户名。 group 指定 worker 进程运行用户所在组。 umask gunicorn 创建文件的缺省权限。 pythonpath 附加到 python path 的目录列表。 日志 accesslog 访问日志文件路径。 access_log_format 日志格式。 例如 %(h)s %(l)s %(u)s %(t)s &quot;%(r)s&quot; %(s)s %(b)s &quot;%(f)s&quot; &quot;%(a)s&quot; 。 errorlog 错误日志路径。 loglever 日志级别。debug, info, warning, error, critical. capture_output 重定向 stdout/stderr 到 error log file。 logger_class 日志实现类。缺省 gunicorn.glogging.Logger 。 logconfig 日志配置文件。同 python 标准日志模块 logging 的配置。 进程名 proc_name 设置进程名 (setproctitle)，在 ps，top 等命令中会看到. 缺省值为 default_proc_name 配置。 server 钩子 on_starting on_reload when_ready pre_fork post_fork post_worker_init worker_init worker_abort pre_exec pre_request post_request child_exit worker-exit nworkers_changed on_exit","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Linux","slug":"程序开发/Linux","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Linux/"},{"name":"Python","slug":"程序开发/Python","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://norhub.com.cn/tags/python/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://norhub.com.cn/tags/ubuntu/"},{"name":"flask","slug":"flask","permalink":"http://norhub.com.cn/tags/flask/"},{"name":"gunicorn","slug":"gunicorn","permalink":"http://norhub.com.cn/tags/gunicorn/"}]},{"title":"如何使用Ubuntu部署Flask+uwsgi","slug":"如何使用Ubuntu部署Flask+uwsgi","date":"2020-04-15T05:55:59.000Z","updated":"2021-06-03T01:15:44.000Z","comments":true,"path":"2020/04/15/如何使用Ubuntu部署Flask+uwsgi/","link":"","permalink":"http://norhub.com.cn/2020/04/15/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Ubuntu%E9%83%A8%E7%BD%B2Flask+uwsgi/","excerpt":"uWSGI是一个Web服务器，它实现了WSGI协议、uwsgi、http等协议。","text":"uWSGI是一个Web服务器，它实现了WSGI协议、uwsgi、http等协议。 一、准备 更新apt源 sudo apt-get update 安装pip sudo apt-get install python3-pip 创建项目文件夹，克隆自己的项目到服务器 sudo mkdir /var/wwwcd /var/wwwgit clone http://** # 这里输入自己的项目地址 二、安装postsql 安装postsql9.5版本，如果是安装最新版本，则不需要写版本号。安装成功后，会自动添加一个名为postgres的系统用户，密码随机。并自动生成一个名为postgres的数据库 sudo apt-get install postgresql-9.5sudo apt-get install python-psycopg2sudo apt-get install libpq-dev 打开客户端工具（psql）修改postgres数据库用户的密码 sudo -u postgres psql # 使用postgres用户登录数据库 # 以下内容内容都是在 postgres=# 下输入ALTER USER postgres WITH PASSWORD &#x27;postgres&#x27;; # 密码设置为123455，有分号才会执行命令\\q #退出客户端 修改ubuntu操作系统的postgres用户的密码 su root # 切换到root用户sudo passwd -d postgres #清空用户postgres的密码sudo -u postgres passwd #设置密码 接下来按要求输入两次密码，要与上面的密码相同 修改PostgresSQL数据库配置实现远程访问 # 打开配置文件，修改以下内容vim /etc/postgresql/9.5/main/postgresql.conf# 监听任何地址访问，修改连接权限#listen_addresses = &#x27;localhost&#x27; 改为 listen_addresses = &#x27;*&#x27;# 启用密码验证#password_encryption = on 改为 password_encryption = on# 打开配置文件，增加以下内容，配置可访问的用户ip段vim /etc/postgresql/9.5/main/pg_hba.conf# 在文档末尾加上以下内容host all all 0.0.0.0 0.0.0.0 md5# 重启PostgreSQL数据库/etc/init.d/postgresql restart# 配置5432端口的防火墙设置iptables -A INPUT -p tcp -m state --state NEW -m tcp --dport 5432 -j ACCEPT 三、安装配置nginx 为什么有了uWSGI为什么还需要nginx？因为nginx具备优秀的静态内容处理能力，然后将动态内容转发给uWSGI服务器，这样可以达到很好的客户端响应。 安装nginx sudo apt-get install nginx mynginx.conf是需要自己创建的一个nginx配置文件，此文件放在项目文件夹中，配置内容如下 server &#123; listen 9000; server_name 203.176.71.157 localhost; access_log /var/www/iclinicAI/logs/access.log; error_log /var/www/iclinicAI/logs/error.log; location / &#123; include uwsgi_params; # 端口号自行设定 uwsgi_pass 127.0.0.1:8004; uwsgi_param UWSGI_CHDIR /var/www/iclinicAI; uwsgi_param UWSGI_SCRIPT manage:app; uwsgi_read_timeout 300; &#125;&#125; 刚建立的配置文件使用符号链接到Nginx配置文件文件夹中 sudo ln -s /var/www/iclinicAI/mynginx.conf /etc/nginx/conf.d/sudo /etc/init.d/nginx restart # 重启nginx 四、配置uwsgi ubuntu安装uwsgi sudo apt-get install uwsgi 或者直接用pip安装 pip install uwsgi 建立uwsgi配置文件，此文件放在项目文件夹中，配置内容如下 [uwsgi]#http=127.0.0.1:8001# uwsgi 启动时所使用的地址与端口socket = 127.0.0.1:8004 # 端口和nginx配置中的一致，可以使用其他端口# 指向网站目录chdir = /var/www/iclinicAImodule = manage# python 启动程序文件wsgi-file = manage.py # python 程序内用以启动的 application 变量名callable = app # 处理器数processes = 4# 线程数threads = 2#状态检测地址stats = 127.0.0.1:9191 # 使用flask项目默认的端口，可以换但必须是flask运行时使用的端口# 添加它，使uwsgi后台运行daemonize =/var/www/iclinicAI/logs/uwsgi.log uwsgi --ini uwsgi.ini 启动# 使用 killall -9 uwsgi 关闭 五、使用supervisor守护进程 首先安装supervisor sudo apt-get install supervisor 生成默认配置文件 echo_supervisord_config &gt; /root/supervisord.conf 加入监控程序的配置 [program:project_name] # project_name这里写上你的项目名称，如我的为[project:chihu]command = uwsgi --ini /var/www/iclinicAI/uwsgi.ini # 跟手动启动的命令一样stopsignal=QUITautostart=trueautorestart=truestdout_logfile=/var/www/iclinicAI/logs/supervisor_chihu.log # 运行日志stderr_logfile=/var/www/iclinicAI/logs/supervisor_chihu_err.log # 错误日志 启动supervisord supervisorctl -c /root/supervisord.confsupervisorctl -c /root/supervisord.conf status # 查看状态#update!!!(如果supervisord.conf里项目有修改敲个命令update一下) 检查uwsgi进程是否正常运行 ps aux|grep uwsgi","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Linux","slug":"程序开发/Linux","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Linux/"},{"name":"Python","slug":"程序开发/Python","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://norhub.com.cn/tags/python/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://norhub.com.cn/tags/ubuntu/"},{"name":"flask","slug":"flask","permalink":"http://norhub.com.cn/tags/flask/"},{"name":"uwsgi","slug":"uwsgi","permalink":"http://norhub.com.cn/tags/uwsgi/"}]},{"title":"如何使用Ubuntu16.04挂载硬盘","slug":"如何使用Ubuntu16.04挂载硬盘","date":"2020-04-15T05:47:36.000Z","updated":"2021-06-03T03:29:00.000Z","comments":true,"path":"2020/04/15/如何使用Ubuntu16.04挂载硬盘/","link":"","permalink":"http://norhub.com.cn/2020/04/15/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Ubuntu16.04%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/","excerpt":"操作前先要添加一块硬盘 查看硬盘位置 sudo fdisk -l 根据磁盘大小，我挂的是40g的，所以很明显是 /dev/sdb","text":"操作前先要添加一块硬盘 查看硬盘位置 sudo fdisk -l 根据磁盘大小，我挂的是40g的，所以很明显是 /dev/sdb 格式化 sudo mkfs.ext4 /dev/sdb 进入命令行 sudo fdisk /dev/sdb 命令行输入 n #添加新分区p #设置主分区#敲3次回车t #更改分区类型，可输入L查看所有分区类型编号83 #linux类型分区w #保存退出 查看新分区,可以看到新分区是/dev/sdb1 sudo fdisk -l 在根下创建目录/data，再挂载它 sudo mkdir /data sudo mount /dev/sdb1 /data 查看硬盘UUID号,记下/dev/sdb1的UUID sudo blkid 编辑配置文件，使机器重启可以自动挂载 sudo vim /etc/fstab 在最后一行添加： UUID=3cbb0105-2d20-444e-9186-3c1ce30239fb /data ext4 defaults 0 0 注：格式为 设备名称 挂载点 分区类型 挂载选项 dump选项 fsck选项 dump选项–这一项为0，就表示从不备份。如果上次用dump备份，将显示备份至今的天数。 fsck选项 –启动时fsck检查的顺序。为0就表示不检查，（/）分区永远都是1，其它的分区只能从2开始，当数字相同就同时检查（但不能有两1） 输入df -h 可以检验磁盘大小","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Linux","slug":"程序开发/Linux","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://norhub.com.cn/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://norhub.com.cn/tags/ubuntu/"}]},{"title":"如何使用SqlServer获取客户端的信息","slug":"如何使用SqlServer获取客户端的信息","date":"2020-04-15T05:43:56.000Z","updated":"2021-05-24T05:21:50.000Z","comments":true,"path":"2020/04/15/如何使用SqlServer获取客户端的信息/","link":"","permalink":"http://norhub.com.cn/2020/04/15/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8SqlServer%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BF%A1%E6%81%AF/","excerpt":"用Sql获取操作的数据库名,计算机名,用户名,网卡物理地址,IP地址,程序名","text":"用Sql获取操作的数据库名,计算机名,用户名,网卡物理地址,IP地址,程序名 创建存储过程 create proc p_getlinkinfo@dbname sysname=null,--要查询的数据库名,默认查询所有数据库的连接信息@includeip bit=0 --是否显示IP地址,因为查询IP地址比较费时,所以增加此控制asdeclare @dbid intset @dbid=db_id(@dbname)create table #tb(id int identity(1,1),dbname sysname,hostname nchar(128),loginname nchar(128),net_address nchar(12),net_ip nvarchar(15),prog_name nchar(128))insert into #tb(hostname,dbname,net_address,loginname,prog_name)select distinct hostname,db_name(dbid),net_address,loginame,program_name from master..sysprocesseswhere hostname&lt;&gt;&#x27;&#x27; and (@dbid is null or dbid=@dbid)if @includeip=0 goto lb_show --如果不显示IP地址,就直接显示declare @sql varchar(500),@hostname nchar(128),@id intcreate table #ip(hostname nchar(128),a varchar(200))declare tb cursor local for select distinct hostname from #tbopen tbfetch next from tb into @hostnamewhile @@fetch_status=0beginset @sql=&#x27;ping &#x27;+@hostname+&#x27; -a -n 1 -l 1&#x27;insert #ip(a) exec master..xp_cmdshell @sqlupdate #ip set hostname=@hostname where hostname is nullfetch next from tb into @hostnameendupdate #tb set net_ip=left(a,patindex(&#x27;%:%&#x27;,a)-1)from #tb a inner join (select hostname,a=substring(a,patindex(&#x27;Ping statistics for %:%&#x27;,a)+20,20) from #ipwhere a like &#x27;Ping statistics for %:%&#x27;) b on a.hostname=b.hostnamelb_show:select id,数据库名=dbname,客户机名=hostname,用户名=loginname,网卡物理地址=net_address,IP地址=net_ip,应用程序名称=prog_name from #tbGO--显示所有本机的连接信息：exec p_getlinkinfo--显示所有本机的连接信息,包含ip地址：exec p_getlinkinfo @includeip=1--显示连接指定数据库的信息：exec p_getlinkinfo @dbname=数据库名,@includeip=1 遇到的问题 错误描述：SQL Server阻止了对组件‘xp_cmdshell’的过程‘sys.xp_cmdshell’的访问。因为此组件已作为此服务嚣安全配置的一部分而被关闭。系统管理员可以通过使用sp_configure启用‘xp_cmdshell’。有关启用‘xp_cmdshell’的详细信息，请参阅sQL帮助文件。 解决方案 sp_configure &#x27;show advanced options&#x27;,1reconfiguregosp_configure &#x27;xp_cmdshell&#x27;,1reconfigurego","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"数据库","slug":"程序开发/数据库","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://norhub.com.cn/tags/sql/"}]},{"title":"Python虚拟环境venv的使用","slug":"Python虚拟环境venv的使用","date":"2020-04-15T05:37:12.000Z","updated":"2021-04-30T02:53:19.000Z","comments":true,"path":"2020/04/15/Python虚拟环境venv的使用/","link":"","permalink":"http://norhub.com.cn/2020/04/15/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83venv%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"因为虚拟环境使用较多，所以python3.4版本起，官方直接内置了venv包 windos环境中使用 创建虚拟环境，第二个venv是虚拟环境名，可以自定义 python -m venv venv 激活虚拟环境 venv\\Scripts\\activate 退出虚拟环境 venv\\Scripts\\deactivate ubuntu环境中使用 安装venv包 sudo apt install python3-venv 创建虚拟环境 python3 -m venv venv 激活虚拟环境 source venv/bin/activate 退出虚拟环境 deactivate","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"程序开发/Python","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://norhub.com.cn/tags/python/"},{"name":"venv","slug":"venv","permalink":"http://norhub.com.cn/tags/venv/"}]},{"title":"如何使用Python内置服务器","slug":"如何使用Python内置服务器","date":"2020-04-15T05:33:23.000Z","updated":"2021-05-21T05:54:25.000Z","comments":true,"path":"2020/04/15/如何使用Python内置服务器/","link":"","permalink":"http://norhub.com.cn/2020/04/15/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Python%E5%86%85%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"python内置了一个下载服务器。例如你的同事要让你传的文件位于某一个目录下面，那么你可以进入这个目录，然后用python开启一个下载服务器","text":"python内置了一个下载服务器。例如你的同事要让你传的文件位于某一个目录下面，那么你可以进入这个目录，然后用python开启一个下载服务器 SimpleHTTPServer搭建web服务器 python -m http.server 8080 目录下如果有index.html，则会显示该页面。浏览器中输入 http://localhost：8080/ 访问 如果有更多需求，完全可以根据自己需要定制，具体的请参见官方文档SimpleHTTPServer，或者直接看源码。我拷贝一段，方便参考： import http.serverimport socketserverPORT = 8000Handler = http.server.SimpleHTTPRequestHandlerhttpd = socketserver.TCPServer((&quot;&quot;, PORT), Handler)print(&quot;serving at port %s&quot;%PORT)httpd.serve_forever() FTP服务器 Python没有内置一个直接可以用的FTP服务器，所以需要第三方组件的支持，我找到的这个组件叫pyftpdlib，首先安装： pip install pyftpdlib 安装完后，和HTTP服器类似，执行以下命令就可以启动一个FTP服务器了： python -m pyftpdlib -p 21 后面的21端口依然是可选的，不填会随机一个，被占用的端口将跳过。 在浏览器敲入本机地址：ftp://localhost:21这时候，是匿名访问，也就是用户名是anonymous，密码为空，如果想要控制访问权限，你需要自己定制服务器，具体的可以参看pyftpdlib Tutorial，我这里拷贝过来一段作为介绍： from pyftpdlib.authorizers import DummyAuthorizerfrom pyftpdlib.handlers import FTPHandlerfrom pyftpdlib.servers import FTPServerimport osdef main(): # 实例化DummyAuthorizer来创建ftp用户 authorizer = DummyAuthorizer() # 参数：用户名，密码，目录，权限 authorizer.add_user(&#x27;user&#x27;, &#x27;12345&#x27;, &#x27;.&#x27;, perm=&#x27;elradfmwM&#x27;) # 匿名登录 authorizer.add_anonymous(os.getcwd()) # 实例化FTP处理程序类 handler = FTPHandler handler.authorizer = authorizer # 定义客户端连接时返回的字符串 handler.banner = &quot;pyftpdlib based ftpd ready.&quot; # 指定伪装地址和要使用的端口范围 # 被动连接。 如果您在NAT后面，请退出 #handler.masquerade_address = &#x27;151.25.42.11&#x27; #handler.passive_ports = range(60000, 65535) # 实例化FTP服务器类并侦听0.0.0.0:2121 address = (&#x27;0.0.0.0&#x27;, 21) server = FTPServer(address, handler) # 设置连接限制 #server.max_cons = 256 #server.max_cons_per_ip = 5 # 启动ftp服务器 server.serve_forever()if __name__ == &#x27;__main__&#x27;: main() 只看代码应该基本知道该怎么用了，add_user显然是添加用户，21是指定端口，当然也可以随机，还有最大连接数max_cons，每个ip最大连接限制，更多的接口建议直接看docstrings。","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"程序开发/Python","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://norhub.com.cn/tags/python/"}]},{"title":"Python虚拟环境pipenv的常用命令","slug":"Python虚拟环境pipenv的常用命令","date":"2020-04-15T05:19:54.000Z","updated":"2021-05-21T05:53:49.000Z","comments":true,"path":"2020/04/15/Python虚拟环境pipenv的常用命令/","link":"","permalink":"http://norhub.com.cn/2020/04/15/Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83pipenv%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"Pipenv可以用于简化Python项目中依赖项的管理。只用了一年， Pipenv 就变成了管理软件包依赖关系的 Python 官方推荐资源。 它汇集了Pip，Pipfile和Virtualenv的功能，是一个强大的命令行工具。","text":"Pipenv可以用于简化Python项目中依赖项的管理。只用了一年， Pipenv 就变成了管理软件包依赖关系的 Python 官方推荐资源。 它汇集了Pip，Pipfile和Virtualenv的功能，是一个强大的命令行工具。 安装和升级pipenv pip install pipenv # 安装pipenvpip install --upgrade pipenv # 升级安装pipenv 使用pipenv 初始化 pipenv install # 初始化项目，将目录更改为python项目文件夹，并启动pipenv。这将创建 pipfile和 pipfile.lock，这两个文件描述了项目依赖环境的配置情况，当有人git-clone了项目，只需安装了pipenv就可以配置出同样的环境。pipenv install --dev # 初始化项目，安装所有依赖项，包括开发包pipenv install --dev --pypi-mirror https://mirrors.aliyun.com/pypi/simple # 使用国内镜像来初始化pipenv --three # 会使用当前系统的Python3创建环境pipenv --two # 使用python2创建pipenv --python 3.6 # 指定某一Python版本创建环境 查看信息 pipenv --where # 显示目录信息pipenv --venv # 显示虚拟环境信息pipenv --py # 显示Python解释器信息 使用虚拟环境 pipenv shell # 激活虚拟环境exit # 退出虚拟环境pipenv – – rm # 删除虚拟环境 其他命令 pipenv run # 不用shell,直接在虚拟环境中执行命令pipenv run python 文件名.py # 使用pipenv环境运行pipenv run pip 命令 # 运行pipalias prp=&quot;pipenv run python&quot; # 给命令设置别名pipenv install requests # 安装相关模块并加入到Pipfilepipenv install django==1.11 # 安装固定版本模块并加入到Pipfilepipenv install --dev nose2 # 在开发环境安装模块nose2pipenv graph # 显示依赖图pipenv check # 检查安全漏洞pipenv uninstall requests # 卸载包并从Pipfile中移除pipenv uninstall --all # 卸载全部包pipenv uninstall --dev # 卸载全部开发包pipenv update --outdated # 查看所有需要更新的包pipenv update # 更新所有包pipenv update &lt;包名&gt; # 更新指定的包pipenv lock -r # 将Pipfile和Pipfile.lock文件里面的包导出为requirements.txt文件pipenv lock -r --dev # 导出开发模块到requirements.txtpipenv install -r path/to/requirements.txt # 如果项目中有requirements.txt文件，pipenv会在安装的时候自动导入。如果需要导入其他位置的requirements.txt，可以用这个命令","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"程序开发/Python","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://norhub.com.cn/tags/python/"},{"name":"pipenv","slug":"pipenv","permalink":"http://norhub.com.cn/tags/pipenv/"}]},{"title":"如何在Ubuntu18环境下安装MySql","slug":"如何在Ubuntu18环境下安装MySql","date":"2020-02-16T12:00:11.000Z","updated":"2021-06-03T01:15:21.000Z","comments":true,"path":"2020/02/16/如何在Ubuntu18环境下安装MySql/","link":"","permalink":"http://norhub.com.cn/2020/02/16/%E5%A6%82%E4%BD%95%E5%9C%A8Ubuntu18%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85MySql/","excerpt":"查看有没有安装MySQL dpkg -l | grep mysql 安装MySQL，注意安装前先更新一下软件源以获得最新版本 sudo apt-get update #更新软件源sudo apt-get install mysql-server #安装mysql 上述命令会安装以下包： apparmor mysql-client-5.7 mysql-common mysql-server mysql-server-5.7 mysql-server-core-5.7 因此无需再安装mysql-client等。安装过程会提示设置mysql root用户的密码，设置完成后等待自动安装即可。默认安装完成就启动了mysql","text":"查看有没有安装MySQL dpkg -l | grep mysql 安装MySQL，注意安装前先更新一下软件源以获得最新版本 sudo apt-get update #更新软件源sudo apt-get install mysql-server #安装mysql 上述命令会安装以下包： apparmor mysql-client-5.7 mysql-common mysql-server mysql-server-5.7 mysql-server-core-5.7 因此无需再安装mysql-client等。安装过程会提示设置mysql root用户的密码，设置完成后等待自动安装即可。默认安装完成就启动了mysql 安装MySQL依赖库 sudo apt-get install libmysqlclient-dev 启动和关闭mysql服务器： service mysql startservice mysql stop 确认是否启动成功，mysql节点处于LISTEN状态表示启动成功： netstat -tap | grep mysql``` 进入mysql shell界面： mysql -u root -p -u 表示选择登陆的用户名， -p 表示登陆的用户密码。 然后通过 show databases; 就可以查看当前的所有数据库。 初始化数据库： mysql_secure_installation ``` shsecure enough. Would you like to setup VALIDATE PASSWORD plugin? # 要安装验证密码插件吗?Press y|Y for Yes, any other key for No: N # 这里我选择NNew password: # 输入要为root管理员设置的数据库密码Re-enter new password: # 再次输入密码Remove anonymous users? (Press y|Y for Yes, any other key for No) : y # 删除匿名账户Disallow root login remotely? (Press y|Y for Yes, any other key for No) : N # 禁止root管理员从远程登录，这里我没有禁止Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y # 删除test数据库并取消对它的访问权限Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y # 刷新授权表，让初始化后的设定立即生效 检查mysql服务状态： systemctl status mysql 现在配置mysql允许远程访问，首先编辑 /etc/mysql/mysql.conf.d/mysqld.cnf 配置文件： vim /etc/mysql/mysql.conf.d/mysqld.cnf 注释掉bind-address = 127.0.0.1 保存退出，然后进入mysql数据库，执行授权命令： mysql -u root -p mysql&gt; grant all on *.* to root@&#x27;%&#x27; identified by &#x27;你的密码&#x27; with grant option;mysql&gt; flush privileges; # 刷新权限mysql&gt; exit 然后执行exit命令退出mysql服务，再执行如下命令重启mysql： systemctl restart mysql 附加说明： sudo /etc/init.d/mysql start 这是启动mysqlsudo /etc/init.d/mysql restart 这是重启sudo /etc/init.d/mysql stop 这是停止 一些问题： https://blog.csdn.net/guoguicheng1314/article/details/80526111 https://blog.csdn.net/vin_1991216/article/details/82632710","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Linux","slug":"程序开发/Linux","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Linux/"},{"name":"数据库","slug":"程序开发/数据库","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://norhub.com.cn/tags/ubuntu/"},{"name":"mySql","slug":"mySql","permalink":"http://norhub.com.cn/tags/mySql/"}]},{"title":"如何使用Ubuntu更换国内apt源","slug":"如何使用Ubuntu更换国内apt源","date":"2020-02-16T11:49:11.000Z","updated":"2021-06-03T01:16:02.000Z","comments":true,"path":"2020/02/16/如何使用Ubuntu更换国内apt源/","link":"","permalink":"http://norhub.com.cn/2020/02/16/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Ubuntu%E6%9B%B4%E6%8D%A2%E5%9B%BD%E5%86%85apt%E6%BA%90/","excerpt":"备份原来的源： sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 更换源: sudo vim /etc/apt/sources.list 将里面文件内容全部替换成下面：","text":"备份原来的源： sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 更换源: sudo vim /etc/apt/sources.list 将里面文件内容全部替换成下面： #deb包deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse##测试版源 deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse# 源码 deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse##测试版源 deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse# Canonical 合作伙伴和附加 deb http://archive.canonical.com/ubuntu/ xenial partnerdeb http://extras.ubuntu.com/ubuntu/ xenial main 执行更新： sudo apt-get update 复损坏的软件包，尝试卸载出错的包，重新安装正确版本的: sudo apt-get -f install 更新软件: sudo apt-get upgrade","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Linux","slug":"程序开发/Linux","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://norhub.com.cn/tags/ubuntu/"}]},{"title":"使用Python将图片转字符画","slug":"使用Python将图片转字符画","date":"2020-01-10T07:34:52.000Z","updated":"2021-05-21T05:54:58.000Z","comments":true,"path":"2020/01/10/使用Python将图片转字符画/","link":"","permalink":"http://norhub.com.cn/2020/01/10/%E4%BD%BF%E7%94%A8Python%E5%B0%86%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E7%94%BB/","excerpt":"使用Pillow可以把图片转成字符画，Pillow是Python平台上的图像处理库，功能强大，简单易用。","text":"使用Pillow可以把图片转成字符画，Pillow是Python平台上的图像处理库，功能强大，简单易用。 安装Pillow 执行下面命令安装Pillow pip install pillow 转换图像 先把图片转成灰度图，然后根据每个像素的灰度替换成不同字符, 从高到低的字符依次是： ‘@’,‘%’,‘#’,‘&amp;’,‘*’,‘+’,‘=’,‘-’,‘.’,‘ ’。``` 代码如下：```pythonfrom PIL import Imagedef imgConvertToTxt(img,txt,scale): &#x27;&#x27;&#x27; img:原图片的完整路径 txt:生成文本的路径 scale:图片缩放倍数（越大字符越少， 适当调大减少不必要的字符） &#x27;&#x27;&#x27; img = Image.open(png) # 将图片转化为灰度图 out = img.convert(&quot;L&quot;) # 展示图片 # out.show() width,height=out.size # 更改图片大小 out = out.resize((int(width/scale),int(height/2/scale))) width,height=out.size asciis=&#x27;@%#&amp;*+=-. &#x27; texts=&#x27;&#x27; for row in range(height): for col in range(width): # 读取灰度 gray=out.getpixel((col,row)) # 根据灰度替换成字符 texts+=asciis[int(gray/255*9)] texts+=&#x27;\\n&#x27; with open(txt,&#x27;w&#x27;)as f: # 写入文件 f.write(texts)if __name__==&#x27;__main__&#x27;: imgConvertToTxt(r&#x27;D:\\Image\\20191008142627.jpg&#x27;,r&#x27;asciis.txt&#x27;,scale=2) 要注意的是scale参数直接决定字符画的字符精度 生成的效果如下所示 原图是这样的 放大后能看到全部是字符组成的 用到的字符越多，生成字符画的细节越明显。可以把原来的十个字符换成下面这七十个 $@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\\&quot;^`&#x27;.","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"程序开发/Python","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://norhub.com.cn/tags/python/"},{"name":"pillow","slug":"pillow","permalink":"http://norhub.com.cn/tags/pillow/"}]},{"title":"如何用Ubuntu18安装Matlab2018b","slug":"如何用Ubuntu18安装Matlab2018b","date":"2020-01-08T03:50:42.000Z","updated":"2021-06-03T01:14:58.000Z","comments":true,"path":"2020/01/08/如何用Ubuntu18安装Matlab2018b/","link":"","permalink":"http://norhub.com.cn/2020/01/08/%E5%A6%82%E4%BD%95%E7%94%A8Ubuntu18%E5%AE%89%E8%A3%85Matlab2018b/","excerpt":"MathWorks公司每年会发布两个版本的MATLAB，一般在3月份发布A版，9月份左右发布B版。两个版本功能并无差异，但相对来说，B版更为稳定，因此个人推荐安装B版。目前最新的版本是MATLAB 2018b，下面给出详细的中文版下载与安装教程。","text":"MathWorks公司每年会发布两个版本的MATLAB，一般在3月份发布A版，9月份左右发布B版。两个版本功能并无差异，但相对来说，B版更为稳定，因此个人推荐安装B版。目前最新的版本是MATLAB 2018b，下面给出详细的中文版下载与安装教程。 下载Matlab2018b https://blog.csdn.net/weixin_41038644/article/details/84668127 开始安装 创建文件夹 mkdir Matlab 挂载第一个镜像 sudo mount -o loop R2018b_glnxa64_dvd1.iso ./Matlab 运行目录下的install开始安装 cd ~ # 先跳出目录sudo /root/Downloads/Matlab/install 选择文件安装密钥 填写密钥09806-07443-53955-64350-21751-41297 选择目录后，点击下一步开始安装。安装到一半会弹框提示需要dvd2才能继续 弹出dvd1 sudo umount Matlab 挂载dvd2 sudo mount -o loop R2018b_glnxa64_dvd2.iso ./Matlab 安装成功后弹出dvd2 sudo umount Matlab 破解Matlab 解压破解文件 unzip MATLAB_R2018b_Linux64_Crack.zip 运行matlab sudo /usr/local/MATLAB/R2018b/bin/matlab 选择离线激活 选择刚才解压的license_standalone.lic文件 激活成功后,再把破解包里的文件替换到matlab完成破解 cp libmwlmgrimpl.so /usr/local/MATLAB/R2018b/bin/glnxa64/matlab_startup_plugins/lmgrimpl/ 添加一个快捷方式 sudo vim /usr/share/applications/Matlab2018b.desktop 按i进入编辑后输入下面内容，然后按ESC输入:wq保存退出 #!/usr/bin/env xdg-open[Desktop Entry]Type=ApplicationIcon=/usr/local/MATLAB/R2018b/toolbox/shared/dastudio/resources/MatlabIcon.pngName=MATLAB R2018bComment=Start MATLAB - The Language of Technical ComputingExec=/usr/local/MATLAB/R2018b/bin/matlabCategories=Development;Math;Science","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Linux","slug":"程序开发/Linux","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Linux/"},{"name":"Matlab","slug":"程序开发/Matlab","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Matlab/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://norhub.com.cn/tags/ubuntu/"},{"name":"matlab","slug":"matlab","permalink":"http://norhub.com.cn/tags/matlab/"}]},{"title":"统计学校各班男女人数该怎么写SQL","slug":"统计学校各班男女人数该怎么写SQL","date":"2019-12-31T04:32:29.000Z","updated":"2021-05-21T05:56:51.000Z","comments":true,"path":"2019/12/31/统计学校各班男女人数该怎么写SQL/","link":"","permalink":"http://norhub.com.cn/2019/12/31/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E6%A0%A1%E5%90%84%E7%8F%AD%E7%94%B7%E5%A5%B3%E4%BA%BA%E6%95%B0%E8%AF%A5%E6%80%8E%E4%B9%88%E5%86%99SQL/","excerpt":"首先统计各班级人数，学生表一条数据代表一个学生， 已经知道学生表有“管理院系，专业，班级名称，班级代码，年级，性别”等信息， 要统计的是在校学生，所以用where条件限定年级在2016~2019。 然后使用group by指定学生班级，在count(*)列就能统计出各班人数 SELECT 管理院系 AS 学院名, 专业 AS 专业名, 班级名称 AS 班级名, 班级代码 AS 班级编号 , COUNT(*) AS 人数FROM EAMS_STUDENT_ALL_INFOWHERE (年级 = 2016 OR 年级 = 2017 OR 年级 = 2018 OR 年级 = 2019)GROUP BY 管理院系, 专业, 班级代码, 班级名称","text":"首先统计各班级人数，学生表一条数据代表一个学生， 已经知道学生表有“管理院系，专业，班级名称，班级代码，年级，性别”等信息， 要统计的是在校学生，所以用where条件限定年级在2016~2019。 然后使用group by指定学生班级，在count(*)列就能统计出各班人数 SELECT 管理院系 AS 学院名, 专业 AS 专业名, 班级名称 AS 班级名, 班级代码 AS 班级编号 , COUNT(*) AS 人数FROM EAMS_STUDENT_ALL_INFOWHERE (年级 = 2016 OR 年级 = 2017 OR 年级 = 2018 OR 年级 = 2019)GROUP BY 管理院系, 专业, 班级代码, 班级名称 统计各班男女人数比较难，最开始准备用LEFT JOIN。用学生表为基础，左连接算出男生人数的学生表，再左连接算出女生人数的学生表， 但是这样做有点麻烦，效率和准确性都不高，所以最后选择了sum函数计算出男女人数方法 SELECT 管理院系 AS 学院名, 专业 AS 专业名, 班级名称 AS 班级名, 班级代码 AS 班级编号 , COUNT(*) AS 人数, SUM(CASE WHEN 性别 = &#x27;女&#x27; THEN 1 ELSE 0 END) AS 女, SUM(CASE WHEN 性别 = &#x27;男&#x27; THEN 1 ELSE 0 END) AS 男FROM EAMS_STUDENT_ALL_INFO aWHERE (年级 = 2016 OR 年级 = 2017 OR 年级 = 2018 OR 年级 = 2019)GROUP BY 管理院系, 专业, 班级代码, 班级名称ORDER BY 班级名称 结果很准确","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"数据库","slug":"程序开发/数据库","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://norhub.com.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Python包管理工具pip的使用","slug":"Python包管理工具pip的使用","date":"2019-12-28T01:50:08.000Z","updated":"2020-01-15T07:32:00.000Z","comments":true,"path":"2019/12/28/Python包管理工具pip的使用/","link":"","permalink":"http://norhub.com.cn/2019/12/28/Python%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7pip%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"pip是Python包管理工具，该工具提供了对Python包的查找、下载、安装、卸载的功能。","text":"pip是Python包管理工具，该工具提供了对Python包的查找、下载、安装、卸载的功能。 常用命令 查看版本和路径 pip --version 获取帮助 pip --help 升级pip版本 pip install -U pip 查看安装包信息 pip show SomePackagepip show -f SomePackage # 查看安装包详细信息 列出已安装的包 pip listpip list -o # 查看可升级的包 在文件中生成包依赖 pip freeze &gt; requirements.txt # 生成txt文件pip install -r requirements.txt # 安装txt依赖 如果只针对项目生成依赖，推荐使用pipreqs pip install pipreqs # 安装pipreqs . --encoding=utf8 --force #在当前目录强制生成txt依赖 在全局环境中使用pipreqs生成当前目录依赖 # 安装pip install pipreqs# 在当前目录生成pipreqs . --encoding=utf8 --force 安装包 pip install SomePackage # 最新版本pip install SomePackage==1.0.4 # 指定版本pip install &#x27;SomePackage&gt;=1.0.4&#x27; # 最小版本pip install SomePackage -i http://pypi.douban.com/simple --trusted-host pypi.douban.com # 用国内镜像安装，可以解决安装慢的问题 包管理 pip install --upgrade SomePackage # 升级包，--upgrade = -Upip uninstall SomePackage # 卸载包pip search SomePackage # 搜索包 安装whl包 pip install wheel # 先安装wheel库pip install XXX.whl # 再安装whl文件&#x27;&#x27;&#x27;whl下载网址https://www.lfd.uci.edu/~gohlke/pythonlibs/&#x27;&#x27;&#x27; 在命令前加python -m来指定python python -m pip install XXXpython2 -m pip install XXX # 使用python2python3 -m pip install XXX # 使用python3 切换pip源 pip install SomePackage -i http://pypi.douban.com/simple --trusted-host pypi.douban.com 除了上面这种用命令方式临时切换pip源，还可以永久切换pip源 在windos下切换，在windows文件管理器中,输入 %APPDATA%会定位到一个新的目录下，在该目录下新建pip文件夹，然后到pip文件夹里面去新建个pip.ini文件，内容如下 [global]timeout = 6000index-url = http://pypi.douban.com/simpletrusted-host = pypi.douban.com 在linux环境下的修改方式和在windows环境下修改方式基本相同，在用户的家目录下面创建名为.pip文件夹，在创建好的.pip文件夹中创建名为pip.conf的文件，内容如下 [global]timeout = 6000index-url = http://pypi.douban.com/simpletrusted-host = pypi.douban.com 如果pip版本大于10.0, 则可以在命令行切换源 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"程序开发/Python","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://norhub.com.cn/tags/python/"},{"name":"pip","slug":"pip","permalink":"http://norhub.com.cn/tags/pip/"}]},{"title":"如何安装OracleLinux系统并搭建数据库","slug":"如何安装OracleLinux系统并搭建数据库","date":"2019-12-26T08:00:16.000Z","updated":"2021-06-03T01:15:13.000Z","comments":true,"path":"2019/12/26/如何安装OracleLinux系统并搭建数据库/","link":"","permalink":"http://norhub.com.cn/2019/12/26/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85OracleLinux%E7%B3%BB%E7%BB%9F%E5%B9%B6%E6%90%AD%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"Oracle Linux以对Oracle软件和硬件支持较好见长,安装Oracle数据库首选系统，最重要的是Oracle数据库跑在上Oracle Linux性能可以提升超过75%","text":"Oracle Linux以对Oracle软件和硬件支持较好见长,安装Oracle数据库首选系统，最重要的是Oracle数据库跑在上Oracle Linux性能可以提升超过75% 一、安装操作系统 选择第一个安装系统 光驱检测选择第二个跳过 语言选英文，中文会乱码 选择第一个基本存储设备 选择第一个“是，忽略数据” 设置Hostname和网络配置 选择时区 设置root密码 选择最后一个，创建自定义布局 创建分区swap，大小是内存的两倍 创建分区boot 把剩余空间放到最后一个分区 选择第二个格式化 选择第二个，将修改写入磁盘 选择桌面Desktop 安装成功重启 重启后进入欢迎页，注意在这里要选择No 用户可以不创建，看个人情况 内存大可以开启kdump,我没有开启 二、配置oracle安装环境 2.1配置系统环境 $ vi /etc/sysconfig/network # 配置主机名NETWORKING=yesHOSTNAME=oracle11g $ vi /etc/hosts #配置host,ip对应主机名10.5.5.132 oracle11g$ service iptables stop # 关闭防火墙$ chkconfig iptables off$ vi /etc/selinux/config # 关闭selinuxSELINUX=disabled $ mkdir -p /soft/yum # 创建软件目录 2.2配置yum源 先拷贝镜像到/soft/目录，然后执行下面的命令 $ mount -o loop -t iso9660 /soft/oraclelinux6.8.iso /soft/yum # 挂载镜像$ cd /etc/yum.repos.d/ # 进入yum源目录$ mv public-yum-ol6.repo public-yum-ol6.repo.bak # 备份源软件源$ vi /etc/yum.repos.d/local.repo[HighAvailability]name=HighAvailabilitybaseurl=file:///soft/yum/HighAvailabilityenabled=1gpgcheck=0[LoadBalancer]name=LoadBalancerbaseurl=file:///soft/yum/LoadBalancerenabled=1gpgcheck=0[ResilientStorage]name=ResilientStoragebaseurl=file:///soft/yum/ResilientStorageenabled=1 gpgcheck=0[Server]name=Serverbaseurl=file:///soft/yum/Serverenabled=1gpgcheck=0# 重新加载yum$ yum clean all$ yum makecache$ yum list$ yum install -y oracle-rdbms-server-11gR2-preinstall # 安装依赖包# 创建目录$ mkdir -p /u01/app/oracle$ chown -R oracle:oinstall /u01/app/oracle$ chmod -R 775 /u01/app/oracle$ mkdir -p /u01/app/oraInventory$ chown -R oracle:oinstall /u01/app/oraInventory$ chmod -R 775 /u01/app/oraInventory 2.3配置oracle用户环境变量 $ su - oracle # 切换到oracle用户$ vi .bash_profile # 配置环境变量TMP=/tmp; export TMPTMPDIR=$TMP; export TMPDIRORACLE_BASE=/u01/app/oracle; export ORACLE_BASEORACLE_HOME=$ORACLE_BASE/product/11.2.0/db_1; export ORACLE_HOMEORACLE_SID=orcl; export ORACLE_SIDORACLE_TERM=xterm; export ORACLE_TERMPATH=/usr/sbin:$PATH; export PATHPATH=$ORACLE_HOME/bin:$PATH; export PATHLD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/lib; export LD_LIBRARY_PATHCLASSPATH=$ORACLE_HOME/JRE:$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib; export CLASSPATHif [ $USER = &quot;oracle&quot; ]; then if [ $SHELL = &quot;/bin/ksh&quot; ]; then ulimit -p 16384 ulimit -n 65536 else ulimit -u 16384 -n 65536 fifi$ source .bash_profile # 让环境变量立即生效 2.4进入安装oracle 安装前先重启系统，然后用oracle用户登录 $ reboot #重启$ cd /soft/ # 进入刚才上传的文件目录$ unzip p13390677_112040_Linux-x86-64_1of7.zip #解压缩$ unzip p13390677_112040_Linux-x86-64_2of7.zip$ cd /soft/database$ ./runInstaller # 开始安装 三、安装oracle 取消勾选 选择跳过 选择只安装软件 选择创建单实例的数据库安装 安装语言使用默认英文 选择安装企业版 Oracle安装路径自动识别到了配置的变量，下一步 安装文件的路径文件目录，自动识别。下一步 选择组的所属，下一步 点击安装 等待安装完成 提示需要root用户执行以下的脚本 打开命令窗口执行脚本 su #切换到root用户/u01/app/oraInventory/orainstRoot.sh #执行第一个脚本/u01/app/oracle/product/11.2.0/db_1/root.sh #执行第二个脚本 执行完去安装窗口点确认 安装完成，点击关闭 四、配置和使用 $ dbca # 配置数据库 选择创建数据库 这里选第一个和第二个都可以，第一个是一般事务数据，第二个是定制数据库。我这里选定制数据库 填写数据库实例名称 取消勾选然后下一步 选择统一的密码，然后自己设置密码 默认需要8位密码，不满8位也可以强制设置 选择数据库文件类型和位置，我这里默认 指定数据库快速恢复区，我不需要，取消勾选 数据库组件，取消勾选 根据需要配置内存，我的配置如图，取消勾选自动记录 根据需要设置最大的连接进程数 配置字符集，因为自己的数据库里用了中文，所以我配置了简体中文，下一步 设置日志组大小等，下一步 创建数据库，完成 确定 开始安装数据库 点击退出，安装完成 $ netca # 配置监听及本地网络服务 监听设置存储在\\data\\oracle\\product\\10.2.0\\db_1\\NETWORK\\ADMIN\\listener.ora 接下来配置远程服务： 注意：若测试不成功有可能是用户登录出错，点击 change login，用户名输入：system，密码输入前面创建数据库时设置的密码 五、启动数据库 $ ln -s /u01/app/oracle/product/11.2.0/db_1/bin/sqlplus /usr/bin # 把sqlplus in到/usr/bin目录，方便使用# 切换到oracle /bin 目录，$ cd $ORACLE_HOME/bin# 启动监听$ lsnrctl start# 查看监听状态$ lsnrctl status# lsnrctl stop命令可以关闭监听# 启动数据库$ sqlplus /nologSQL&gt; connect /as sysdbaSQL&gt; startup# shutdown immediate 命令来关闭数据 如果要关闭数据库可以用oracle的shutdown命令用来关闭当前实例，有4个可选参数：normal、transactional、immediate和abort。不带参数时默认是normal。 这几个参数的差异体现在以下几个维度： 是否允许新的连接； 当前已连接的回话是否自动断开； 当前未提交的事务是等待用户提交完成还是自动回滚； 关闭时是否需要做检查点； 启动时是否需要进行实例恢复。 shutdown normal：不允许新的连接、等待会话结束、等待事务结束、做一个检查点并关闭数据文件。启动时不需要实例恢复。 shutdown transactional：不允许新的连接、不等待会话结束、等待事务结束、做一个检查点并关闭数据文件。启动时不需要实例恢复。 shutdown immediate：不允许新的连接、不等待会话结束、不等待事务结束、做一个检查点并关闭数据文件。没有结束的事务是自动rollback的。启动时不需要实例恢复。 shutdown abort：不允许新的连接、不等待会话结束、不等待事务结束、不做检查点且没有关闭数据文件。启动时自动进行实例恢复。 六、创建表空间和用户 $ sqlplus / as sysdba# 查询临时表空间文件的绝对路径。如果需要的话，可以通过查询来写定绝对路径。一般用$&#123;ORACLE_HOME&#125;就可以了SQL&gt; select name from v$tempfile;# 创建临时表空间‘OACESHI_TEMP’SQL&gt; create temporary tablespace OACESHI_TEMP tempfile&#x27;$&#123;ORACLE_HOME&#125;/oradata/OACESHI_TEMP.bdf&#x27; size 100m reuse autoextend on next 20mmaxsize unlimited;# 查询用户表空间文件的绝对路径SQL&gt; select name from v$datafile;# 创建表空间‘OACESHIDB’SQL&gt; create tablespace OACESHIDB datafile &#x27;$&#123;ORACLE_HOME&#125;/oradata/OACESHIDB.bdf&#x27; size 100Mreuse autoextend on next 40M maxsize unlimited default storage(initial 128k next 128kminextents 2 maxextents unlimited);# 创建用户‘OACESHI’和密码‘OACESHI’，指定上边创建的临时表空间和表空间SQL&gt; create user OACESHI identified by OACESHI default tablespace OACESHIDB temporary tablespace OACESHI_TEMP;# 赋予权限SQL&gt; grant connect,resource to OACESHI;SQL&gt; grant create any view to OACESHI;# 或者快速创建dba用户SQL&gt; create user TEST identified by TEST;SQL&gt; grant dba to TEST; 七、问题解决 注意： 操作监听和数据库都需要切换到oracle用户下 操作数据库还需要通过sqlplus，以管理员身份登录到oracle plsql连接时无监听程序 https://www.linuxidc.com/Linux/2017-10/147393.htm","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"数据库","slug":"程序开发/数据库","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://norhub.com.cn/tags/linux/"},{"name":"oracle","slug":"oracle","permalink":"http://norhub.com.cn/tags/oracle/"}]},{"title":"如何在Ubuntu18和Centos7下搭建Hadoop2.6.5集群和伪集群","slug":"如何在Ubuntu18和Centos7下搭建Hadoop2.6.5集群和伪集群","date":"2019-12-17T09:45:32.000Z","updated":"2020-07-31T02:15:00.000Z","comments":true,"path":"2019/12/17/如何在Ubuntu18和Centos7下搭建Hadoop2.6.5集群和伪集群/","link":"","permalink":"http://norhub.com.cn/2019/12/17/%E5%A6%82%E4%BD%95%E5%9C%A8Ubuntu18%E5%92%8CCentos7%E4%B8%8B%E6%90%AD%E5%BB%BAHadoop2.6.5%E9%9B%86%E7%BE%A4%E5%92%8C%E4%BC%AA%E9%9B%86%E7%BE%A4/","excerpt":"Hadoop被公认是一套行业大数据标准开源软件，在分布式环境下提供了海量数据的处理能力。单节点集群是利用一台主机模拟Hadoop运行环境，可以使用Hadoop所有模块","text":"Hadoop被公认是一套行业大数据标准开源软件，在分布式环境下提供了海量数据的处理能力。单节点集群是利用一台主机模拟Hadoop运行环境，可以使用Hadoop所有模块 一、准备 1.1创建Hadoop用户 在操作过程中，ubuntu系统和centos系统不同的执行的命令我都做了说明，没有说明的命令则两种系统都能执行 ubuntu命令 sudo useradd -m hadoop -s /bin/bash # 创建hadoop用户，并使用/bin/bash作为shellsudo passwd hadoop # 为hadoop用户设置密码，之后需要连续输入两次密码sudo adduser hadoop sudo # 为hadoop用户增加管理员权限su - hadoop # 切换当前用户为用户hadoopsudo apt-get update # 更新软件包信息 centos命令 sudo useradd -m hadoop -s /bin/bash # 创建hadoop用户，并使用/bin/bash作为shellsudo passwd hadoop # 设置密码sudo visudo # 设置管理员，找到root ALL=(ALL) ALL这行，在下面增加一行hadoop ALL=(ALL) ALLsu - hadoop # 切换当前用户为用户hadoop 1.2设置SSH无密码登录 ubuntu命令 sudo apt-get install openssh-server # 安装SSH serverssh localhost # 登陆SSH，第一次登陆输入yesexit # 退出登录的ssh localhostcd ~/.ssh/ # 如果没法进入该目录，执行一次ssh localhostssh-keygen -t rsa # 产生秘钥进行后续身份验证，需三次回车确认cat ./id_rsa.pub &gt;&gt; ./authorized_keys # 将产生的Key放到许可证文件中ssh localhost # 此时已不需密码即可登录localhost centos命令 rpm -qa | grep ssh # 查看ssh是否安装，如果包含了SSH client跟SSH server，则不需要再安装sudo yum install openssh-clients # 安装sshsudo yum install openssh-serverssh localhost # 登陆SSH，输入yes,然后按提示输入hadoop密码exit # 退出刚才的 ssh localhostcd ~/.ssh/ # 若没有该目录，请先执行一次ssh localhostssh-keygen -t rsa # 会有提示，都按回车就可以cat id_rsa.pub &gt;&gt; authorized_keys # 加入授权chmod 600 ./authorized_keys # 修改文件权限 二、安装JDK ubuntu命令 java -version # 查看当前java版本，未出现版本信息代表未安装sudo apt-get install default-jdk # 使用apt-get安装openJDKjava -version # 再次查询Java版本，查看是否安装成功 查询java安装路径路径，记住该路径，下面步骤中的配置要用到 update-alternatives --display java centos命令 安装openJDK yum install java-1.8.0-openjdk.x86_64 java-1.8.0-openjdk-devel.x86_64 jdk路径 /usr/lib/jvm/java-1.8.0-openjdk 三、下载安装Hadoop ubuntu命令 apt-get install wget centos命令 yum -y install wget 下载安装hadoop wget http://archive.apache.org/dist/hadoop/core/hadoop-2.6.4/hadoop-2.6.5.tar.gz # 下载hadoopsudo tar -zxvf hadoop-2.6.5.tar.gz # 解压缩sudo mv hadoop-2.6.5 /usr/local/hadoop # 将hadoop移动到/usr/local/hadoopll /usr/local/hadoop # 查看hadoop安装目录 bin是运行文件目录，包括Hadoop、HDFS和YARN sbin是shell文件目录，包括start-all.sh、stop-all.sh etc/hadoop目录包含hadoop配置文件 lib是hadoop函数库目录 logs系统日志目录 四、设置Hadoop环境变量 在终端输入命令打开编辑器 使用vim编辑器，点击键盘&quot;i&quot;, 就能开始编辑。输入配置文件内容后，点击键盘&quot;esc&quot;键，然后输入:wq来保存退出 ubuntu命令 sudo vim --version # 检查是否安装vimsudo apt-get install vim # 安装vimsudo vim ~/.bashrc # 编辑.bashrc centos命令 sudo rpm -qa|grep vim # 检查是否安装vimsudo yum install vim -y # 安装vimsudo vim ~/.bashrc # 编辑.bashrc 在编辑器中输入下面内容 # 设置jdk安装路径，参考安装jdk的部分输出的路径export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64# centos的jdk路径，使用cento时取消下面注释# export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk# 设置HADOOP_HOME为安装路径export HADOOP_HOME=/usr/local/hadoop# 设置PATHexport PATH=$PATH:$HADOOP_HOME/binexport PATH=$PATH:$HADOOP_HOME/sbin# 其他环境变量export CLASSPATH=$($HADOOP_HOME/bin/hadoop classpath):$CLASSPATHexport HADOOP_MAPRED_HOME=$HADOOP_HOMEexport HADOOP_COMMON_HOME=$HADOOP_HOMEexport HADOOP_HDFS_HOME=$HADOOP_HOMEexport YARN_HOME=$HADOOP_HOME# 连接库相关设置export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/nativeexport HADOOP_OPTS=&quot;-DJava.library.path=$HADOOP_HOME/lib&quot;export JAVA_LIBRARY_PATH=$HADOOP_HOME/lib/native:$JAVA_LIBRARY_PATH 或者图形界面可以使用sudo gedit ~/.bashrc命令编辑，在编辑器中输入后，然后按ctrl+s保存，再关闭编辑器 让设置立即生效 source ~/.bashrc 五、修改Hadoop配置文件 编辑hadoop-env.sh sudo vim /usr/local/hadoop/etc/hadoop/hadoop-env.sh 设置JAVA_HOME的路径，参考安装jdk的部分输出的路径，编辑完成保存退出 修改core-site.xml文件 sudo vim /usr/local/hadoop/etc/hadoop/core-site.xml 输入以下内容 &lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/hadoop_data&lt;/value&gt; &lt;description&gt;Abase for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 第一个节点是临时目录，第二个节点是HDFS默认名称 编辑yarn-site.xml sudo vim /usr/local/hadoop/etc/hadoop/yarn-site.xml 输入以下内容 &lt;configuration&gt;&lt;!-- Site specific YARN configuration properties --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 编辑mapred-site.xml，mapred-site.xml用于监控Map与Reduce程序的JobTracker任务分配情况以及TaskTracker任务运行情况 sudo cp /usr/local/hadoop/etc/hadoop/mapred-site.xml.template /usr/local/hadoop/etc/hadoop/mapred-site.xml #复制模板文件sudo vim /usr/local/hadoop/etc/hadoop/mapred-site.xml 输入以下内容 &lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 这个节点是设置mapreduce框架为yarn 编辑 hdfs-site.xml sudo vim /usr/local/hadoop/etc/hadoop/hdfs-site.xml 输入下面内容 &lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/hadoop_data/hdfs/namenode&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/hadoop_data/hdfs/datanode&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 第一个节点是设置blocks副本备份数量，第二个是NameNode数据存储目录，第三个是DataNode数据存储目录 六、创建并格式化HDFS目录 sudo mkdir -p /usr/local/hadoop/hadoop_data/hdfs/namenode #创建namenode数据存储目录sudo mkdir -p /usr/local/hadoop/hadoop_data/hdfs/datanode #创建datanode数据存储目录sudo chown -R hadoop /usr/local/hadoop #修改Hadoop目录所有者为hadoophadoop namenode -format #格式化HDFS 七、启动Hadoop start-dfs.sh #启动HDFSstart-yarn.sh #启动Hadoop MapReduce框架Yarn 或者同时启动 start-all.sh 输入jps查看进程是否启动 查看Hadoop ResourceManager Web页面，打开浏览器输入 http://localhost:8088/ 查看NameNode HDFS Web页面，打开浏览器输入 http://localhost:50070/ 八、搭建hadoop集群 Hadoop 的运行方式是由配置文件决定的（运行 Hadoop 时会读取配置文件），因此如果需要从伪分布式模式切换回分布式模式，需要修改配置文件，先按照上面一二三四步骤搭建环境，再进行下面的步骤 准备四台计算机，其中有一台namenode和三台datanode 8.1 配置第一台datanode服务器 先把ip改成固定ip ubuntu改ip命令 sudo vim /etc/network/interfaces #改ip,sudo /etc/init.d/networking restart #重启网卡 centos改ip命令 vim /etc/sysconfig/network-scripts/ifcfg-ens192 #改ip,service network restart #重启网卡 修改主机名为data1 sudo vim /etc/hostname 编辑hosts文件，每台ip对应一个主机 sudo vim /etc/hosts 编辑core-site.xml sudo vim /usr/local/hadoop/etc/hadoop/core-site.xml 输入以下内容 &lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://master:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 编辑yarn-site.xml vim /usr/local/hadoop/etc/hadoop/yarn-site.xml 输入下面内容 &lt;configuration&gt;&lt;!-- Site specific YARN configuration properties --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt; &lt;value&gt;master:8025&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt; &lt;value&gt;master:8030&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt; &lt;value&gt;master:8050&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 以上设置说明： ResourceManager主机与NodeManager的连接地址为8025 ResourceManager与ApplicationMater的连接地址为8030 ResourceManager与客户端的连接地址为8050 编辑mapred-site.xml vim /usr/local/hadoop/etc/hadoop/mapred-site.xml 输入下面内容 &lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapred.job.tracker&lt;/name&gt; &lt;value&gt;master:54311&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 编辑hdfs-site.xml vim /usr/local/hadoop/etc/hadoop/hdfs-site.xml 输入下面内容,设置datanode目录 &lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;3&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/hadoop_data/hdfs/datanode&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 重复以上步骤再建立3台主机，如果是VM虚拟机则复制3台虚拟机 8.2 配置第二台datanode服务器 先把ip改成固定ip ubuntu改ip命令 sudo vim /etc/network/interfaces #改ip,sudo /etc/init.d/networking restart #重启网卡 centos改ip命令 vim /etc/sysconfig/network-scripts/ifcfg-ens192 #改ip,service network restart #重启网卡 改主机名为data2 sudo vim /etc/hostname 8.3 配置第三台datanode服务器 先把ip改成固定ip ubuntu改ip命令 sudo vim /etc/network/interfaces #改ip,sudo /etc/init.d/networking restart #重启网卡 centos改ip命令 vim /etc/sysconfig/network-scripts/ifcfg-ens192 #改ip,service network restart #重启网卡 改主机名为data3 sudo vim /etc/hostname 8.4 配置一台namenode服务器 先把ip改成固定ip ubuntu改ip命令 sudo vim /etc/network/interfaces #改ip,sudo /etc/init.d/networking restart #重启网卡 centos改ip命令 vim /etc/sysconfig/network-scripts/ifcfg-ens192 #改ip,service network restart #重启网卡 改主机名为master sudo vim /etc/hostname 编辑hdfs-site.xml vim /usr/local/hadoop/etc/hadoop/hdfs-site.xml 输入下面内容,设置datanode目录 &lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;3&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/hadoop_data/hdfs/namenode&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 编辑masters文件,主要是告诉hadoop哪一台服务器是namenode sudo vim /usr/local/hadoop/etc/hadoop/masters # 设置master 编辑slaves文件,主要是告诉hadoop哪一台服务器是datanode sudo vim /usr/local/hadoop/etc/hadoop/slaves #设置data1,data2,data3 手动重启所有服务器 8.5 mater连接data1、data2、data3，创建HDFS目录 使用master主机连接data1进行配置 ssh data1 # ssh连接到data1sudo rm -rf /usr/local/hadoop/hadoop_data/hdfs # 删除HDFS所有目录mkdir -p /usr/local/hadoop/hadoop_data/hdfs/datanode # 创建DataNode存储目录sudo chown -R hadoop:hadoop /usr/local/hadoop # 更改目录所有者exit # 中断连接回到master 使用master主机连接data2进行配置 ssh data2 # ssh连接到data1sudo rm -rf /usr/local/hadoop/hadoop_data/hdfs # 删除HDFS所有目录mkdir -p /usr/local/hadoop/hadoop_data/hdfs/datanode # 创建DataNode存储目录sudo chown -R hadoop:hadoop /usr/local/hadoop # 更改目录所有者exit # 中断连接回到master 使用master主机连接data3进行配置 ssh data3 # ssh连接到data1sudo rm -rf /usr/local/hadoop/hadoop_data/hdfs # 删除HDFS所有目录mkdir -p /usr/local/hadoop/hadoop_data/hdfs/datanode # 创建DataNode存储目录sudo chown -R hadoop:hadoop /usr/local/hadoop # 更改目录所有者exit # 中断连接回到master 创建并格式化namenode HDFS目录 su - hadoop # 切换hadoop用户sudo rm -rf /usr/local/hadoop/hadoop_data/hdfs # 删除HDFS所有目录mkdir -p /usr/local/hadoop/hadoop_data/hdfs/namenode # 创建DataNode存储目录sudo chown -R hadoop:hadoop /usr/local/hadoop # 更改目录所有者hadoop namenode -format # 格式化namenode HDFS目录 8.6 启动集群 start-dfs.sh # 启动HDFS，第一次会询问，输入yesstart-yarn.sh # 启动Hadoop MapReduce框架Yarn 或者同时启动 start-all.sh 如果要停止可以用 stop-all.sh 查看master启动的进程 jsp 查看data1启动的进程 ssh data1 # ssh连接data1jps # 查看data1的进程exit # 退出连接 8.7 端口开放说明 集群启动后由于存在防火墙，所以hadoop无法访问，可以按需开放以下端口。或者直接关闭，一劳永逸 组件 节点 默认端口 配置 用途说明 HDFS DataNode 50010 dfs.datanode.address datanode服务端口，用于数据传输 HDFS DataNode 50075 dfs.datanode.http.address http服务的端口 HDFS DataNode 50475 dfs.datanode.https.address https服务的端口 HDFS DataNode 50020 dfs.datanode.ipc.address ipc服务的端口 HDFS NameNode 50070 dfs.namenode.http-address http服务的端口 HDFS NameNode 50470 dfs.namenode.https-address https服务的端口 HDFS NameNode 8020 fs.defaultFS 接收Client连接的RPC端口，用于获取文件系统metadata信息。 HDFS journalnode 8485 dfs.journalnode.rpc-address RPC服务 HDFS journalnode 8480 dfs.journalnode.http-address HTTP服务 HDFS ZKFC 8019 dfs.ha.zkfc.port ZooKeeper FailoverController，用于NN HA YARN ResourceManager 8032 yarn.resourcemanager.address RM的applications manager(ASM)端口 YARN ResourceManager 8030 yarn.resourcemanager.scheduler.address scheduler组件的IPC端口 YARN ResourceManager 8031 yarn.resourcemanager.resource-tracker.address IPC YARN ResourceManager 8033 yarn.resourcemanager.admin.address IPC YARN ResourceManager 8088 yarn.resourcemanager.webapp.address http服务端口 YARN NodeManager 8040 yarn.nodemanager.localizer.address localizer IPC YARN NodeManager 8042 yarn.nodemanager.webapp.address http服务端口 YARN NodeManager 8041 yarn.nodemanager.address NM中container manager的端口 YARN JobHistory Server 10020 mapreduce.jobhistory.address IPC YARN JobHistory Server 19888 mapreduce.jobhistory.webapp.address http服务端口 HBase Master 60000 hbase.master.port IPC HBase Master 60010 hbase.master.info.port http服务端口 HBase RegionServer 60020 hbase.regionserver.port IPC HBase RegionServer 60030 hbase.regionserver.info.port http服务端口 HBase HQuorumPeer 2181 hbase.zookeeper.property.clientPort HBase-managed ZK mode，使用独立的ZooKeeper集群则不会启用该端口。 HBase HQuorumPeer 2888 hbase.zookeeper.peerport HBase-managed ZK mode，使用独立的ZooKeeper集群则不会启用该端口。 HBase HQuorumPeer 3888 hbase.zookeeper.leaderport HBase-managed ZK mode，使用独立的ZooKeeper集群则不会启用该端口。 Hive Metastore 9083 /etc/default/hive-metastore中export PORT=来更新默认端口 Hive HiveServer 10000 /etc/hive/conf/hive-env.sh中export HIVE_SERVER2_THRIFT_PORT=来更新默认端口 ZooKeeper Server 2181 /etc/zookeeper/conf/zoo.cfg中clientPort= 对客户端提供服务的端口 ZooKeeper Server 2888 /etc/zookeeper/conf/zoo.cfg中server.x=[hostname]:nnnnn[:nnnnn]，标蓝部分 follower用来连接到leader，只在leader上监听该端口。 ZooKeeper Server 3888 /etc/zookeeper/conf/zoo.cfg中server.x=[hostname]:nnnnn[:nnnnn]，标蓝部分 用于leader选举的。只在electionAlg是1,2或3(默认)时需要。 例如开放8025端口 sudo firewall-cmd --zone=public --permanent --add-port=8025/tcp 其他防火墙命令 sudo firewall-cmd --state # 运行状态sudo firewall-cmd --list-all # 查看防火墙规则sudo firewall-cmd --zone=public --list-ports # 已经开放的端口sudo systemctl stop firewalld.service # 停止防火墙sudo systemctl start firewalld.service # 运行防火墙sudo systemctl restart firewalld.service # 重启防火墙sudo firewall-cmd --zone=public --remove-port=5672/tcp --permanent # 关闭5672端口netstat -lnpt # 查看监听的端口netstat -lnpt | grep 5672 # 查看端口被哪个进程占用 九、Hadoop常用的HDFS命令 命令 说明 hadoop fs -mkdir 创建HDFS目录 hadoop fs -ls 列出HDFS目录 hadoop fs -copyFromLocal 使用copyFromLocal复制本地文件到HDFS hadoop fs -put 使用put复制本地文件到HDFS hadoop fs -cat 列出HDFS目录下的文件内容 hadoop fs -copyToLocal 使用copyToLocal将HDFS上的文件复制到本地 hadoop fs -cp 复制HDFS文件 hadoop fs -rm 删除HDFS文件 操作示例 hadoop fs -mkdir -p /usr/hadoop/test # 创建/usr/hadoop/test目录hadoop fs -copyFromLocal /home/hadoop/data.txt /usr/hadoop/test/test.txt # 复制本地文件到hdfs目录hadoop fs -cat /home/hadoop/data.txt|more # 查看文件内容，如果内容较大|more是分页显示hadoop fs -put /home/hadoop/data.txt /usr/hadoop/test/test.txt # put可以直接覆盖文件，copyFromLocal则需要-f命令# put和copyFromLocal的区别是put可以接受标准输入echo abc | hadoop fs -put - /usr/hadoop/test/test.txt # 输入abc到hdfs文件内容ls /home/hadoop | hadoop fs -put - /usr/hadoop/test/hadooplist.txt # 将本地目录列表存储到hdfs文件hadoop fs -copyToLocal /usr/hadoop/test/hadooplist.txt # 复制hdfs文件到本地hadoop fs -get /usr/hadoop/test/hadooplist.txt local.txt # 使用get复制hdfs文件到本地hadoop fs -cp /usr/hadoop/test/hadooplist.txt /usr/hadoop # 复制hdfs文件到其他目录hadoop fs -rm /usr/hadoop/test/hadooplist.txt # 删除hdfs文件hadoop fs -rm -R /usr/hadoop/test # 删除hdfs目录hadoop fs -ls -R / # 查看所有hdfs目录,-R表示子目录也要看 十、遇到的问题和解决办法 在安装完成后发现namenode进程没有启动，打不开 http://localhost:50070/ 页面。首先去查看日志 cd /usr/local/hadoop/logs #进入日志目录sz hadoop-hadoop-namenode-csubuntu.log #下载日志 发现是9000端口被占用 sudo netstat -lnp | grep 9000 #查看9000端口占用 看到是nginx占用了9000端口,把nginx停止就能重新启动hadoop ps -ef | grep nginx #查看nginx主进程sudo kill -9 主进程号 #强制停止Nginx 启动hadoop守护进程","categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Linux","slug":"程序开发/Linux","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://norhub.com.cn/tags/ubuntu/"},{"name":"hdfs","slug":"hdfs","permalink":"http://norhub.com.cn/tags/hdfs/"},{"name":"hadoop","slug":"hadoop","permalink":"http://norhub.com.cn/tags/hadoop/"}]}],"categories":[{"name":"程序开发","slug":"程序开发","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"程序开发/Python","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Python/"},{"name":"其他","slug":"其他","permalink":"http://norhub.com.cn/categories/%E5%85%B6%E4%BB%96/"},{"name":"VSCode","slug":"程序开发/VSCode","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/VSCode/"},{"name":"软件推荐","slug":"软件推荐","permalink":"http://norhub.com.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"},{"name":"PC","slug":"软件推荐/PC","permalink":"http://norhub.com.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/PC/"},{"name":"GIT","slug":"程序开发/GIT","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/GIT/"},{"name":"HTML","slug":"程序开发/HTML","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/HTML/"},{"name":"Linux","slug":"程序开发/Linux","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Linux/"},{"name":"Docker","slug":"程序开发/Docker","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Docker/"},{"name":"安卓","slug":"软件推荐/安卓","permalink":"http://norhub.com.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/%E5%AE%89%E5%8D%93/"},{"name":"数据库","slug":"程序开发/数据库","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Matlab","slug":"程序开发/Matlab","permalink":"http://norhub.com.cn/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/Matlab/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://norhub.com.cn/tags/%E6%AD%A3%E5%88%99/"},{"name":"python","slug":"python","permalink":"http://norhub.com.cn/tags/python/"},{"name":"cmd","slug":"cmd","permalink":"http://norhub.com.cn/tags/cmd/"},{"name":"vscode","slug":"vscode","permalink":"http://norhub.com.cn/tags/vscode/"},{"name":"代理","slug":"代理","permalink":"http://norhub.com.cn/tags/%E4%BB%A3%E7%90%86/"},{"name":"git","slug":"git","permalink":"http://norhub.com.cn/tags/git/"},{"name":"css","slug":"css","permalink":"http://norhub.com.cn/tags/css/"},{"name":"html","slug":"html","permalink":"http://norhub.com.cn/tags/html/"},{"name":"div","slug":"div","permalink":"http://norhub.com.cn/tags/div/"},{"name":"linux","slug":"linux","permalink":"http://norhub.com.cn/tags/linux/"},{"name":"docker","slug":"docker","permalink":"http://norhub.com.cn/tags/docker/"},{"name":"centos","slug":"centos","permalink":"http://norhub.com.cn/tags/centos/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://norhub.com.cn/tags/ubuntu/"},{"name":"spark","slug":"spark","permalink":"http://norhub.com.cn/tags/spark/"},{"name":"psutil","slug":"psutil","permalink":"http://norhub.com.cn/tags/psutil/"},{"name":"破解","slug":"破解","permalink":"http://norhub.com.cn/tags/%E7%A0%B4%E8%A7%A3/"},{"name":"hdfs","slug":"hdfs","permalink":"http://norhub.com.cn/tags/hdfs/"},{"name":"hive","slug":"hive","permalink":"http://norhub.com.cn/tags/hive/"},{"name":"flask","slug":"flask","permalink":"http://norhub.com.cn/tags/flask/"},{"name":"hexo","slug":"hexo","permalink":"http://norhub.com.cn/tags/hexo/"},{"name":"数据库","slug":"数据库","permalink":"http://norhub.com.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"oracle","slug":"oracle","permalink":"http://norhub.com.cn/tags/oracle/"},{"name":"matlab","slug":"matlab","permalink":"http://norhub.com.cn/tags/matlab/"},{"name":"gunicorn","slug":"gunicorn","permalink":"http://norhub.com.cn/tags/gunicorn/"},{"name":"uwsgi","slug":"uwsgi","permalink":"http://norhub.com.cn/tags/uwsgi/"},{"name":"sql","slug":"sql","permalink":"http://norhub.com.cn/tags/sql/"},{"name":"venv","slug":"venv","permalink":"http://norhub.com.cn/tags/venv/"},{"name":"pipenv","slug":"pipenv","permalink":"http://norhub.com.cn/tags/pipenv/"},{"name":"mySql","slug":"mySql","permalink":"http://norhub.com.cn/tags/mySql/"},{"name":"pillow","slug":"pillow","permalink":"http://norhub.com.cn/tags/pillow/"},{"name":"pip","slug":"pip","permalink":"http://norhub.com.cn/tags/pip/"},{"name":"hadoop","slug":"hadoop","permalink":"http://norhub.com.cn/tags/hadoop/"}]}